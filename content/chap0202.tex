\section{向量}\label{sec:向量}

pbrt提供了2D和3D向量类。
两者都由基本向量元素参数化，
因此易于实例化整数和浮点类型的向量。

\begin{lstlisting}
`\initcode{Vector Declarations}{=}\initnext{VectorDeclarations}`
template <typename T> class `\initvar{Vector2}{}` {
public:
    `\refcode{Vector2 Public Methods}{}`
    `\refcode{Vector2 Public Data}{}`
};

`\refcode{Vector Declarations}{+=}\lastnext{VectorDeclarations}`
template <typename T> class `\initvar{Vector3}{}` {
public:
    `\refcode{Vector3 Public Methods}{}`
    `\refcode{Vector3 Public Data}{}`
};
\end{lstlisting}

接下来，我们一般只介绍\refvar{Vector3}{}方法的实现；
它们都有\refvar{Vector2}{}的相应版本，实现的区别也很简单。

一个向量表示为分量的元组，以所在定义空间$x,y,z$（3D）轴的形式给出其表达。
一个3D向量$\bm v$的各个分量写作$\bm v_x,\bm v_y$和$\bm v_z$。

\begin{lstlisting}
`\initcode{Vector2 Public Data}{=}`
T `\initvar[Vector2::x]{x}{}`, `\initvar[Vector2::y]{y}{}`;

`\initcode{Vector3 Public Data}{=}`
T `\initvar[Vector3::x]{x}{}`, `\initvar[Vector3::y]{y}{}`, `\initvar[Vector3::z]{z}{}`;
\end{lstlisting}

另一实现方式是单个模板类再用一个维度整数参数化，
并以若干{\ttfamily T}值构成的数组表示坐标。
尽管这种方法能减少代码总量，
但向量的单个分量不能以{\ttfamily v.x}等形式访问。
我们认为这种情况下，为了更透明地访问元素，
向量实现中多一点代码是值得的。

然而，一些例程发现能简单地遍历向量的分量是很有用的；
向量类也提供了C++操作符以索引分量，
这样给定向量{\ttfamily v}，有{\ttfamily v[0]==v.x}等。
\begin{lstlisting}
`\initcode{Vector3 Public Methods}{=}\initnext{Vector3PublicMethods}`
T operator[](int i) const { 
    Assert(i >= 0 && i <= 2);
    if (i == 0) return x;
    if (i == 1) return y;
    return z;
}
T &operator[](int i) { 
    Assert(i >= 0 && i <= 2);
    if (i == 0) return x;
    if (i == 1) return y;
    return z;
}
\end{lstlisting}

为了方便起见，{\ttfamily typedef}指定了许多向量常用的类型，
这样在别处代码中它们会有更简洁的名字。
\begin{lstlisting}
`\refcode{Vector Declarations}{+=}\lastcode{VectorDeclarations}`
typedef `\refvar{Vector2}{}`<`\refvar{Float}{}`> `\initvar{Vector2f}{}`;
typedef `\refvar{Vector2}{}`<int>   `\initvar{Vector2i}{}`;
typedef `\refvar{Vector3}{}`<`\refvar{Float}{}`> `\initvar{Vector3f}{}`;
typedef `\refvar{Vector3}{}`<int>   `\initvar{Vector3i}{}`;
\end{lstlisting}

接触过面向对象设计的读者可能质疑我们让向量元素数据可公开访问的决定。
通常，数据成员只在其类内是可访问的，
外部代码想要访问或修改类的内容必须通过良好定义的选择器\sidenote{译者注：原文selector。}
和修改器\sidenote{译者注：原文mutator。}函数API。
尽管我们通常统一这条设计原则
（但也有第\refchap{绪论}中“扩展阅读”一节关于面向数据的设计的讨论），
可是这里它并不合适。
选择器和修改器函数的目的是隐藏类内实现细节。
对于向量，隐藏其设计的基本部分没有好处且会增加使用代码的体积。

默认情况下，值$(x,y,z)$设为零，
但类的用户也可以为每个分类提供值。
如果用户确实提供了值，
我们就用宏\refvar{Assert}{()}检查确认其中没有
“not a number”（NaN）值。
当以优化模式编译时，该宏从编译代码中消失，
节约验证这种情况的开销。
NaN几乎一定表明系统存在bug；
如果NaN是某些计算生成的，
我们就要尽快排查以便隔离其来源
（更多关于NaN值的讨论详见\refsub{浮点算术}）。
\begin{lstlisting}
`\refcode{Vector3 Public Methods}{+=}\lastnext{Vector3PublicMethods}`
`\refvar{Vector3}{}`() { x = y = z = 0; }
`\refvar{Vector3}{}`(T x, T y, T z)
    : x(x), y(y), z(z) {
    `\refvar{Assert}{}`(!`\refvar{HasNaNs}{}`());
}
\end{lstlisting}

检查NaN的代码只是为$x,y$和$z$分量中的每一个调用函数{\ttfamily std::isnan()}。
\begin{lstlisting}
`\refcode{Vector3 Public Methods}{+=}\lastnext{Vector3PublicMethods}`
bool `\initvar{HasNaNs}{}`() const {
    return std::isnan(x) || std::isnan(y) || std::isnan(z);
}
\end{lstlisting}

向量的加法和减法逐分量进行。
向量加减法的一般几何解释如\reffig{2.3}和\reffig{2.4}所示。
\begin{figure}[htbp]
    \centering\input{Pictures/chap02/Vectoraddition.tex}
    \caption{（左图）向量加法：$\bm v+\bm w$。
        （右图）注意和$\bm v+\bm w$表示由$\bm v$与$\bm w$构成的平行四边形的对角线，
        表明向量加法满足交换律：$\bm v+\bm w=\bm w+\bm v$。}
    \label{fig:2.3}
\end{figure}
\begin{figure}[htbp]
    \centering\input{Pictures/chap02/Vectorsubtraction.tex}
    \caption{（左图）向量减法。
        （右图）如果我们考虑由两个向量构成的平行四边形，
        则$\bm w-\bm v$（虚线）与$-\bm v-\bm w$（未画出）表示对角线。}
    \label{fig:2.4}
\end{figure}

\begin{lstlisting}
`\refcode{Vector3 Public Methods}{+=}\lastnext{Vector3PublicMethods}`
`\refvar{Vector3}{}`<T> operator+(const `\refvar{Vector3}{}`<T> &v) const {
    return `\refvar{Vector3}{}`(x + v.x, y + v.y, z + v.z);
}
`\refvar{Vector3}{}`<T>& operator+=(const `\refvar{Vector3}{}`<T> &v) {
    x += v.x; y += v.y; z += v.z;
    return *this;
}
\end{lstlisting}

两个向量的减法类似，此处不再说明。

向量可以逐分量与标量相乘，从而改变其长度。
为了涵盖源码中可能用到的这一运算的所有不同形式
（即{\ttfamily v*s}、{\ttfamily s*v}以及{\ttfamily v*=s}），需要三个函数：
\begin{lstlisting}
`\refcode{Vector3 Public Methods}{+=}\lastnext{Vector3PublicMethods}`
`\refvar{Vector3}{}`<T> operator*(T s) const { return `\refvar{Vector3}{}`<T>(s*x, s*y, s*z); }
`\refvar{Vector3}{}`<T> &operator*=(T s) {
    x *= s; y *= s; z *= s;
    return *this;
}
\end{lstlisting}
\begin{lstlisting}
`\initcode{Geometry Inline Functions}{=}\initnext{GeometryInlineFunctions}`
template <typename T> inline `\refvar{Vector3}{}`<T>
operator*(T s, const `\refvar{Vector3}{}`<T> &v) { return v * s; }
\end{lstlisting}

类似地，向量也可以逐分量除以一个标量。
标量除法的代码和标量乘法相似，
但一个标量除以向量是没有定义的所以是不允许的。
\subsection{点积与叉积}\label{sub:点积与叉积}