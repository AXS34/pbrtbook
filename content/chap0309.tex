\section{控制舍入误差}\label{sec:控制舍入误差}

\begin{remark}
    本节含有高级内容，第一次阅读时可以跳过。
\end{remark}

到目前为止，我们都是根据基于实数的理想化算术运算
纯粹地讨论光线——形状相交算法。该方法已经让我们走得很远了，
尽管有个重要事实是计算机只能表示有限的数量，
因此它实际上不能表示所有实数。
计算机用浮点数代替实数，它有固定的存储要求。
然而，因为结果可能无法在特定量的内存中表示，
每执行一次浮点运算就可能引入误差。

该误差的累积对相交测试的精度有些许影响。
首先，它可能造成完全错过有效的相交——
例如，一个精确值是正数的相交处$t$值算成了负的。
而且，算得的光线——形状交点可能在形状实际曲面的上面或下面。
这导致一个问题：当从算得的交点开始为阴影射线和反射光线追踪新光线时，
若射线端点在实际曲面之下，我们可能求得一次与曲面错误的再相交。
反之，若端点在曲面上面离得太远，阴影和反射可能会脱钩（见\reffig{3.39}）。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Selfintersectioncases.tex}
    \caption{可能在图像中造成可见错误的舍入误差问题几何设置。
        左边的入射光线与曲面相交。在左图中，算得的交点（黑圆圈）略低于曲面
        且阴影射线端点过低的“epsilon”偏移可能导致错误的自相交，
        因为阴影射线端点（白圆圈）仍在曲面之下；因此错误地认定光源被遮挡了。
        右图中，太高的“epsilon”导致错过了有效相交，
        因为射线端点通过了遮挡面。}
    \label{fig:3.39}
\end{figure}

在光线追踪中解决该问题的典型实践是将生成的射线偏移固定的“射线epsilon”值
\sidenote{译者注：epsilon即希腊字母$\epsilon$。}，
忽略沿射线$\bm p+t\bm d$比某个$t_{\min}$还近的任何相交。
\reffig{3.40}展示了为什么该方法需要很高的$t_{\min}$值才能高效工作：
如果生成的射线相对于曲面非常倾斜，
则在离射线很远处可能会发生错误的射线相交。
不幸的是，大的$t_{\min}$值会造成射线端点相对远离原始交点，
这又反过来造成错过附近的有效相交，导致阴影和反射丢失细节。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Selfintersectionobliqueray.tex}
    \caption{如果算得的交点（实心圆）低于曲面且生成的射线是斜的，
        在与射线端点有一定距离的地方可能会发生错误的再相交（空心圆）。
        如果用沿射线的最小$t$值消除附近的相交，
        需要相对大的$t_{\min}$才能处理好倾斜射线。}
    \label{fig:3.40}
\end{figure}

本节中，我们将介绍浮点算术基本思想并描述分析浮点计算误差的技术。
然后我们将这些方法用于本章之前介绍的光线——形状算法
并展示怎样计算带有有界误差的光线交点。
这将允许我们保守地定位射线端点，这样就永远不会求得错误的自相交，
而又保留了与实际交点极其接近的射线端点使得错误脱靶被最小化。
反过来也不需要额外的“射线epsilon”值。

\subsection{浮点算术}\label{sub:浮点算术}
计算只能在容于有限量内存的数字的有限表示上执行。


\begin{lstlisting}
`\initcode{Global Constants}{=}\initnext{GlobalConstants}`
static constexpr `\refvar{Float}{}` `\initvar{MaxFloat}{}` = std::numeric_limits<`\refvar{Float}{}`>::max();
static constexpr `\refvar{Float}{}` `\initvar{Infinity}{}` = std::numeric_limits<`\refvar{Float}{}`>::infinity();
\end{lstlisting}

\subsubsection*{实用例程}

\begin{lstlisting}
`\initcode{Global Inline Functions}{=}\initnext{GlobalInlineFunctions}`
inline uint32_t `\initvar{FloatToBits}{}`(float f) {
    uint32_t ui;
    memcpy(&ui, &f, sizeof(float));
    return ui;
}
\end{lstlisting}

\subsubsection*{算术运算}
\begin{lstlisting}
`\refcode{Global Constants}{+=}\lastnext{GlobalConstants}`
static constexpr `\refvar{Float}{}` `\initvar{MachineEpsilon}{}` =
       std::numeric_limits<`\refvar{Float}{}`>::epsilon() * 0.5;
\end{lstlisting}

\subsubsection*{误差传播}
\begin{lstlisting}
`\refcode{Global Inline Functions}{+=}\lastnext{GlobalInlineFunctions}`
inline constexpr `\refvar{Float}{}` `\initvar{gamma}{}`(int n) {
    return (n * `\refvar{MachineEpsilon}{}`) / (1 - n * `\refvar{MachineEpsilon}{}`);
}
\end{lstlisting}

\subsubsection*{运行误差分析}
\begin{lstlisting}
`\initcode{EFloat Public Methods}{=}\initnext{EFloatPublicMethods}`
`\initvar{EFloat}{}`() { }
`\refvar{EFloat}{}`(float v, float err = 0.f) : `\refvar[EFloat::v]{v}{}`(v), `\refvar[EFloat::err]{err}{}`(err) {
    `\refcode{Store high-precision reference value in EFloat}{}`
}
\end{lstlisting}

\begin{lstlisting}
`\initcode{EFloat Private Data}{=}\initnext{EFloatPrivateData}`
float `\initvar[EFloat::v]{v}{}`;
float `\initvar[EFloat::err]{err}{}`;
\end{lstlisting}

\begin{lstlisting}
`\refcode{EFloat Private Data}{+=}\lastcode{EFloatPrivateData}`
#ifndef NDEBUG
long double `\initvar[EFloat::ld]{ld}{}`;
#endif // NDEBUG
\end{lstlisting}

\begin{lstlisting}
`\refcode{EFloat Public Methods}{+=}\lastnext{EFloatPublicMethods}`
float `\initvar{UpperBound}{}`() const { return `\refvar{NextFloatUp}{}`(`\refvar[EFloat::v]{v}{}` + `\refvar[EFloat::err]{err}{}`); }
float `\initvar{LowerBound}{}`() const { return `\refvar{NextFloatDown}{}`(`\refvar[EFloat::v]{v}{}` - `\refvar[EFloat::err]{err}{}`); }
\end{lstlisting}

\subsection{稳定的三角形相交}\label{sub:稳定的三角形相交}

\subsection{定界交点误差}\label{sub:定界交点误差}