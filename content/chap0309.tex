\section{控制舍入误差}\label{sec:控制舍入误差}

\begin{remark}
    本节含有高级内容，第一次阅读时可以跳过。
\end{remark}

到目前为止，我们都是根据基于实数的理想化算术运算
纯粹地讨论光线——形状相交算法。该方法已经让我们走得很远了，
尽管有个重要事实是计算机只能表示有限的数量，
因此它实际上不能表示所有实数。
计算机用浮点数代替实数，它有固定的存储要求。
然而，因为结果可能无法在特定量的内存中表示，
每执行一次浮点运算就可能引入误差。

该误差的累积对相交测试的精度有些许影响。
首先，它可能造成完全错过有效的相交——
例如，一个精确值是正数的相交处$t$值算成了负的。
而且，算得的光线——形状交点可能在形状实际曲面的上面或下面。
这导致一个问题：当从算得的交点开始为阴影射线和反射光线追踪新光线时，
若射线端点在实际曲面之下，我们可能求得一次与曲面错误的再相交。
反之，若端点在曲面上面离得太远，阴影和反射可能会脱钩（见\reffig{3.39}）。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Selfintersectioncases.tex}
    \caption{可能在图像中造成可见错误的舍入误差问题几何设置。
        左边的入射光线与曲面相交。在左图中，算得的交点（黑圆圈）略低于曲面
        且阴影射线端点过低的“epsilon”偏移可能导致错误的自相交，
        因为阴影射线端点（白圆圈）仍在曲面之下；因此错误地认定光源被遮挡了。
        右图中，太高的“epsilon”导致错过了有效相交，
        因为射线端点通过了遮挡面。}
    \label{fig:3.39}
\end{figure}

在光线追踪中解决该问题的典型实践是将生成的射线偏移固定的“射线epsilon”值
\sidenote{译者注：epsilon即希腊字母$\epsilon$。}，
忽略沿射线$\bm p+t\bm d$比某个$t_{\min}$还近的任何相交。
\reffig{3.40}展示了为什么该方法需要很高的$t_{\min}$值才能高效工作：
如果生成的射线相对于曲面非常倾斜，
则在离射线很远处可能会发生错误的射线相交。
不幸的是，大的$t_{\min}$值会造成射线端点相对远离原始交点，
这又反过来造成错过附近的有效相交，导致阴影和反射丢失细节。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Selfintersectionobliqueray.tex}
    \caption{如果算得的交点（实心圆）低于曲面且生成的射线是斜的，
        在与射线端点有一定距离的地方可能会发生错误的再相交（空心圆）。
        如果用沿射线的最小$t$值消除附近的相交，
        需要相对大的$t_{\min}$才能处理好倾斜射线。}
    \label{fig:3.40}
\end{figure}

本节中，我们将介绍浮点算术基本思想并描述分析浮点计算误差的技术。
然后我们将这些方法用于本章之前介绍的光线——形状算法
并展示怎样计算带有有界误差的光线交点。
这将允许我们保守地定位射线端点，这样就永远不会求得错误的自相交，
而又保留了与实际交点极其接近的射线端点使得错误脱靶被最小化。
反过来也不需要额外的“射线epsilon”值。

\subsection{浮点算术}\label{sub:浮点算术}
计算必须在容纳于有限量内存的数字的有限表示上执行；
计算机上无法表示实数的无限集合。
一种这样的有限表示是定点，例如给定一个16位整数，
有人可能通过除以256将其映射为正实数。
这允许我们表示值之间具有相等间距$\displaystyle\frac{1}{256}$的
范围$\displaystyle\left[0,\frac{65535}{256}\right]=\left[0,255+\frac{255}{256}\right]$。
\keyindex{定点数}{fixed-point number}{}可以用整数算术运算高效实现
（该特性使其在早期不支持浮点计算的个人计算机上很流行），
但是它们受制于许多缺点：其中，它们能表示的最大数字是受限的，
且不能精确表示非常小的接近于零的数。

计算机上实数的另一种表示是\keyindex{浮点数}{floating-point number}{}。
它用\keyindex{符号}{sign}{}、\keyindex{有效数字}{significand}{}\footnote{单词“\protect\keyindex{尾数}{mantissa}{}”
    常用来代替“有效数字”，但浮点纯粹主义者注意到“尾数”在对数上下文中
    有不同含义而因此更偏爱“有效数字”。这里我们遵循该用法。}和\keyindex{指数}{exponent}{}表示数字：
本质上和\keyindex{科学计数法}{scientific notation}{}相同但用固定数量的数字表示有效数字和指数。
（下文中，我们将只讨论以2为底的数字。）
这种表示能够用固定数量的存储对极大范围的数字进行表示和执行计算。

用浮点算术的程序员通常知道浮点是不精确的；
有时这种看法导致了浮点算术是不可预测的观念。
本节中我们将看到浮点算术有精心设计的基础反而
能计算特定计算中引入误差的保守边界。
对于光线追踪计算，该误差常意外地小。

现代CPU和GPU几乎无处不在地基于电气与电子工程师协会
\sidenote{译者注：即Institute of Electrical and Electronics Engineers (IEEE)，
    是电气工程与电子工程以及相关学科的专业协会，成立于1963年1月，总部在美国纽约。
    其范围已经扩展到电气、电子、通信、计算机工程、计算机科学与信息技术等诸多领域，
    是世界上最大的技术专业组织。}
颁布的标准\parencite*{10.1109/IEEESTD.1985.82928,10.1109/IEEESTD.2008.4610935}实现了浮点算术模型。
（今后当我们说浮点时，我们特指IEEE 754规定的32位浮点数。）
IEEE 754技术标准规定了内存中浮点数的格式以及
精度和浮点计算舍入的特定规则；
正是这些规则使得对给定浮点值中出现的误差进行严格推导成为可能。

\subsubsection*{浮点表示}
IEEE标准规定32位浮点用1位符号、8位指数和23位有效数字表示。
用了8位的指数$e$范围为从0到255；
实际用的指数$e_{\mathrm{b}}$是通过偏置$e$算得的：
\begin{align*}
    e_{\mathrm{b}}=e-127\, .
\end{align*}

当存储\keyindex{规范化的}{normalized}{}浮点值时有效数字实际有24位精度。
当有效数字和指数表示规范化的数字时，有效数字中没有前导零。
在\keyindex{二进制}{binary}{}中，这意味着有效数字开头的数字必须是一；
反过来，没必要显式存储该值。
因此，隐式前导的1位和编码有效数字小数部分的23位给出了总共24位的精度。

给定符号$s=\pm 1$、有效数字$m$和指数$e$，相应的浮点值为
\begin{align*}
    s\times 1.m\times2^{e-127}\, .
\end{align*}

例如，浮点数6.5可以通过规范化的有效数字写作$1.101_2\times2^2$，
其中下标2表示以2为底的值\sidenote{译者注：即二进制。}
（如果非整数的二进制数不够直观，可以注意
小数点右边第一个数表示$\displaystyle 2^{-1}=\frac{1}{2}$，以此类推）。
因此，我们有
\begin{align*}
    (1\times2^0+1\times2^{-1}+0\times2^{-2}+1\times2^{-3})\times2^2=1.625\times2^2=6.5\, .
\end{align*}
$e_{\mathrm{b}}=2$，所以$e=129=10000001_2$且$m=10100000000000000000000_2$。

浮点在内存中的布局是符号位在32位值的最高位
（负号用一位编码），然后是指数和有效数字。
因此，对于值6.5其内存中的二进制表示是
\begin{align*}
    0\ 10000001\ 10100000000000000000000=40\mathrm{d}00000_{16}\, .
\end{align*}

同样，浮点值1.0有$m=0\ldots0_2$和$e_{\mathrm{b}}=0$，所以$e=127=01111111_2$，它的二进制表示为
\begin{align*}
    0\ 01111111\ 00000000000000000000000=3\mathrm{f}800000_{16}\, .
\end{align*}

该\keyindex{十六进制}{hexadecimal}{}值值得记住，因为调试时它常出现于内存转储。

该表示隐含了整个范围内两个相邻的二的幂次之间
可表示的浮点数之间的间隔是均匀的（它对应于有效数字位增一）。
在范围$[2^e,2^{e+1})$内，间隔为
\begin{align}\label{eq:3.6}
    2^{e-23}\, .
\end{align}
因此对1和2之间的浮点数，$e=0$，
浮点值间的间隔为$2^{-23}\approx1.19209\ldots\times10^{-7}$。
该间隔也称为\keyindex{最后一位上的单位值}{unit in last place}{}(ulp)\sidenote{译者注：也叫“最小精度单位”。}的大小；
注意一个ulp的大小由相应浮点值决定——更大的数的ulp比更小的数的ulp相对更大。

按我们目前描述的表示是不可能恰好将零表示为浮点数的。
这事显然不可接受，所以最小指数$e=0$，
或说$e_{\mathrm{b}}=-127$，被留出来特殊对待。
对于该指数，浮点值解释为有效数字中没有隐式前导一位，
这意味全零位的有效数字会得到
\begin{align*}
    s\times0.0\ldots0_2\times2^{-127}=0\, .
\end{align*}

去掉有效数字前导一位也能表示\sidenote{译者注：我完善了这两个式子。}\keyindex{非规范化的}{denormalized}{}数：
如果总是出现前导一，则最小的32位浮点是
\begin{align*}
    1.{\underbrace{0\ldots0}_{\text{23个0}}}\ _2\times2^{-127}\approx5.8774718\times10^{-39}\, .
\end{align*}
没有前导一位，最小值是
\begin{align*}
    0.\underbrace{0\ldots0}_{\text{22个0}}1_2\times2^{-126}=2^{-23}\times2^{-126}\approx1.4012985\times10^{-45}\, .
\end{align*}
有了一些表示这些小值的能力可以避免需要将非常小的数舍入为零。

注意该表示同时有“正”和“负”零值。
该细节对程序员大多是透明的。
例如，标准保证了比较{\ttfamily -0.0 == 0.0}为真，
即使这两值在内存中的表示不同。

最大指数，$e=255$，也保留作特殊对待。
因此，可以表示的最大规范化浮点值有$e=254$（或$e_{\mathrm{b}}=127$）且约为\sidenote{译者注：我完善了该式。}
\begin{align*}
    1.{\underbrace{1\ldots1}_{\text{23个1}}}\ _2\times2^{127}=(2-2^{-23})\times2^{127}\approx3.402823\times10^{38}\, .
\end{align*}

对于$e=255$，若有效数字位全是零，则该值依据符号位对应正或负无穷。
例如，在浮点中执行像1/0的计算会得到无穷值。
对无穷的算术运算得到无穷。
比较时，正无穷大于任何非无穷值，负无穷类似。

常数\refvar{MaxFloat}{}和\refvar{Infinity}{}分别初始化为可表示的最大和“无穷”浮点值。
我们令其可在单独的常数中获取，这样使用这些值的代码
就不需要用唠叨的C++标准库调用来获取它们的值了。
\begin{lstlisting}
`\initcode{Global Constants}{=}\initnext{GlobalConstants}`
static constexpr `\refvar{Float}{}` `\initvar{MaxFloat}{}` = std::numeric_limits<`\refvar{Float}{}`>::max();
static constexpr `\refvar{Float}{}` `\initvar{Infinity}{}` = std::numeric_limits<`\refvar{Float}{}`>::infinity();
\end{lstlisting}

对于$e=255$，非零有效数字位对应
特殊的NaN值\sidenote{译者注：原文误写为$e_b=255$，已修正。}，
它由诸如取负数平方根或尝试计算0/0的运算得到。
NaN随计算传播：\keyindex{运算对象}{operand}{}之一
为NaN本身的任何算术运算总是返回NaN。
因此，如果NaN出现于一长串计算中，
我们就知道该方式中的某处出错了。
在调试构建中，pbrt有许多\refvar{Assert}{()}语句检查NaN值，
因为我们几乎从不希望它们出现在事件的常规过程中。
任何与NaN值的比较返回假；
因此检查{\ttfamily !(x == x)}用来检查值是否不是数字
\footnote{这是编译器不得对包含浮点值的表达式执行
看似明显且安全的代数简化的少数几个地方之一——
这个特别的比较不得简化为{\ttfamily false}。
启用编译器的“快速数学”或“执行不安全的数学优化”标志
可能会允许执行这些优化。但是错误行为可能引入pbrt中。}。
为了清楚起见，我们用C++标准库函数{\ttfamily std::isnan()}来检查NaN值。

\subsubsection*{实用例程}

\begin{lstlisting}
`\initcode{Global Inline Functions}{=}\initnext{GlobalInlineFunctions}`
inline uint32_t `\initvar{FloatToBits}{}`(float f) {
    uint32_t ui;
    memcpy(&ui, &f, sizeof(float));
    return ui;
}
\end{lstlisting}

\subsubsection*{算术运算}
\begin{lstlisting}
`\refcode{Global Constants}{+=}\lastnext{GlobalConstants}`
static constexpr `\refvar{Float}{}` `\initvar{MachineEpsilon}{}` =
       std::numeric_limits<`\refvar{Float}{}`>::epsilon() * 0.5;
\end{lstlisting}

\subsubsection*{误差传播}
\begin{lstlisting}
`\refcode{Global Inline Functions}{+=}\lastnext{GlobalInlineFunctions}`
inline constexpr `\refvar{Float}{}` `\initvar{gamma}{}`(int n) {
    return (n * `\refvar{MachineEpsilon}{}`) / (1 - n * `\refvar{MachineEpsilon}{}`);
}
\end{lstlisting}

\subsubsection*{运行误差分析}
\begin{lstlisting}
`\initcode{EFloat Public Methods}{=}\initnext{EFloatPublicMethods}`
`\initvar{EFloat}{}`() { }
`\refvar{EFloat}{}`(float v, float err = 0.f) : `\refvar[EFloat::v]{v}{}`(v), `\refvar[EFloat::err]{err}{}`(err) {
    `\refcode{Store high-precision reference value in EFloat}{}`
}
\end{lstlisting}

\begin{lstlisting}
`\initcode{EFloat Private Data}{=}\initnext{EFloatPrivateData}`
float `\initvar[EFloat::v]{v}{}`;
float `\initvar[EFloat::err]{err}{}`;
\end{lstlisting}

\begin{lstlisting}
`\refcode{EFloat Private Data}{+=}\lastcode{EFloatPrivateData}`
#ifndef NDEBUG
long double `\initvar[EFloat::ld]{ld}{}`;
#endif // NDEBUG
\end{lstlisting}

\begin{lstlisting}
`\refcode{EFloat Public Methods}{+=}\lastnext{EFloatPublicMethods}`
float `\initvar{UpperBound}{}`() const { return `\refvar{NextFloatUp}{}`(`\refvar[EFloat::v]{v}{}` + `\refvar[EFloat::err]{err}{}`); }
float `\initvar{LowerBound}{}`() const { return `\refvar{NextFloatDown}{}`(`\refvar[EFloat::v]{v}{}` - `\refvar[EFloat::err]{err}{}`); }
\end{lstlisting}

\subsection{稳定的三角形相交}\label{sub:稳定的三角形相交}

\subsection{定界交点误差}\label{sub:定界交点误差}