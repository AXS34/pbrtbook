\section{控制舍入误差}\label{sec:控制舍入误差}

\begin{remark}
    本节含有高级内容，第一次阅读时可以跳过。
\end{remark}

到目前为止，我们都是根据基于实数的理想化算术运算
纯粹地讨论光线——形状相交算法。该方法已经让我们走得很远了，
尽管有个重要事实是计算机只能表示有限的数量，
因此它实际上不能表示所有实数。
计算机用浮点数代替实数，它有固定的存储要求。
然而，因为结果可能无法在特定量的内存中表示，
每执行一次浮点运算就可能引入误差。

该误差的累积对相交测试的精度有些许影响。
首先，它可能造成完全错过有效的相交——
例如，一个精确值是正数的相交处$t$值算成了负的。
而且，算得的光线——形状交点可能在形状实际曲面的上面或下面。
这导致一个问题：当从算得的交点开始为阴影射线和反射光线追踪新光线时，
若射线端点在实际曲面之下，我们可能求得一次与曲面错误的再相交。
反之，若端点在曲面上面离得太远，阴影和反射可能会脱钩（见\reffig{3.39}）。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Selfintersectioncases.tex}
    \caption{可能在图像中造成可见错误的舍入误差问题几何设置。
        左边的入射光线与曲面相交。在左图中，算得的交点（黑圆圈）略低于曲面
        且阴影射线端点过低的“epsilon”偏移可能导致错误的自相交，
        因为阴影射线端点（白圆圈）仍在曲面之下；因此错误地认定光源被遮挡了。
        右图中，太高的“epsilon”导致错过了有效相交，
        因为射线端点通过了遮挡面。}
    \label{fig:3.39}
\end{figure}

在光线追踪中解决该问题的典型实践是将生成的射线偏移固定的“射线epsilon”值
\sidenote{译者注：epsilon即希腊字母$\epsilon$。}，
忽略沿射线$\bm p+t\bm d$比某个$t_{\min}$还近的任何相交。
\reffig{3.40}展示了为什么该方法需要很高的$t_{\min}$值才能高效工作：
如果生成的射线相对于曲面非常倾斜，
则在离射线很远处可能会发生错误的射线相交。
不幸的是，大的$t_{\min}$值会造成射线端点相对远离原始交点，
这又反过来造成错过附近的有效相交，导致阴影和反射丢失细节。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Selfintersectionobliqueray.tex}
    \caption{如果算得的交点（实心圆）低于曲面且生成的射线是斜的，
        在与射线端点有一定距离的地方可能会发生错误的再相交（空心圆）。
        如果用沿射线的最小$t$值消除附近的相交，
        需要相对大的$t_{\min}$才能处理好倾斜射线。}
    \label{fig:3.40}
\end{figure}

本节中，我们将介绍浮点算术基本思想并描述分析浮点计算误差的技术。
然后我们将这些方法用于本章之前介绍的光线——形状算法
并展示怎样计算带有有界误差的光线交点。
这将允许我们保守地定位射线端点，这样就永远不会求得错误的自相交，
而又保留了与实际交点极其接近的射线端点使得错误脱靶被最小化。
反过来也不需要额外的“射线epsilon”值。

\subsection{浮点算术}\label{sub:浮点算术}
计算必须在容于有限量内存的数字的有限表示上执行；
计算机上无法表示实数的无限集合。
一种这样的有限表示是定点，例如给定16位整数，
有人可能通过除以256将其映射为正实数。
这允许我们表示值间等间距为$\displaystyle\frac{1}{256}$的
范围$\displaystyle\left[0,\frac{65535}{256}\right]=\left[0,255+\frac{255}{256}\right]$。
\keyindex{定点数}{fixed-point number}{}可以用整数算术运算高效实现
（该特性使其在早期不支持浮点计算的个人计算机上很流行），
但是它们受制于许多缺点：其中，它们能表示的最大数字是受限的，
且不能精确表示非常小的接近于零的数。

计算机上实数的另一种表示是\keyindex{浮点数}{floating-point number}{}。
它用\keyindex{符号}{sign}{}、\keyindex{有效数字}{significand}{}\footnote{单词“\protect\keyindex{尾数}{mantissa}{}”
    常用来代替“有效数字”，但浮点纯粹主义者注意到“尾数”在对数上下文中
    有不同含义而因此更偏爱“有效数字”。这里我们遵循该用法。}和\keyindex{指数}{exponent}{}表示数字：
本质上和\keyindex{科学计数法}{scientific notation}{}相同但用固定数量的数字表示有效数字和指数。
（下文中，我们将只讨论以2为底的数字。）
这种表示能够用固定数量的存储对极大范围的数字进行表示和执行计算。

用浮点算术的程序员通常知道浮点是不精确的；
有时这种看法导致了浮点算术是不可预测的观念。
本节中我们将看到浮点算术有精心设计的基础反而
能计算特定计算中引入误差的保守边界。
对于光线追踪计算，该误差常意外地小。

现代CPU和GPU几乎无处不在地基于电气与电子工程师协会
\sidenote{译者注：即Institute of Electrical and Electronics Engineers (IEEE)，
    是电气工程与电子工程以及相关学科的专业协会，成立于1963年1月，总部在美国纽约。
    其范围已经扩展到电气、电子、通信、计算机工程、计算机科学与信息技术等诸多领域，
    是世界上最大的技术专业组织。}
颁布的标准\parencite*{10.1109/IEEESTD.1985.82928,10.1109/IEEESTD.2008.4610935}实现了浮点算术模型。
（今后当我们说浮点时，我们特指IEEE 754规定的32位浮点数。）
IEEE 754技术标准规定了内存中浮点数的格式以及
精度和浮点计算舍入的特定规则；
正是这些规则使得对给定浮点值中出现的误差进行严格推导成为可能。

\subsubsection*{浮点表示}
IEEE标准规定32位浮点用1位符号、8位指数和23位有效数字表示。

\begin{lstlisting}
`\initcode{Global Constants}{=}\initnext{GlobalConstants}`
static constexpr `\refvar{Float}{}` `\initvar{MaxFloat}{}` = std::numeric_limits<`\refvar{Float}{}`>::max();
static constexpr `\refvar{Float}{}` `\initvar{Infinity}{}` = std::numeric_limits<`\refvar{Float}{}`>::infinity();
\end{lstlisting}

\subsubsection*{实用例程}

\begin{lstlisting}
`\initcode{Global Inline Functions}{=}\initnext{GlobalInlineFunctions}`
inline uint32_t `\initvar{FloatToBits}{}`(float f) {
    uint32_t ui;
    memcpy(&ui, &f, sizeof(float));
    return ui;
}
\end{lstlisting}

\subsubsection*{算术运算}
\begin{lstlisting}
`\refcode{Global Constants}{+=}\lastnext{GlobalConstants}`
static constexpr `\refvar{Float}{}` `\initvar{MachineEpsilon}{}` =
       std::numeric_limits<`\refvar{Float}{}`>::epsilon() * 0.5;
\end{lstlisting}

\subsubsection*{误差传播}
\begin{lstlisting}
`\refcode{Global Inline Functions}{+=}\lastnext{GlobalInlineFunctions}`
inline constexpr `\refvar{Float}{}` `\initvar{gamma}{}`(int n) {
    return (n * `\refvar{MachineEpsilon}{}`) / (1 - n * `\refvar{MachineEpsilon}{}`);
}
\end{lstlisting}

\subsubsection*{运行误差分析}
\begin{lstlisting}
`\initcode{EFloat Public Methods}{=}\initnext{EFloatPublicMethods}`
`\initvar{EFloat}{}`() { }
`\refvar{EFloat}{}`(float v, float err = 0.f) : `\refvar[EFloat::v]{v}{}`(v), `\refvar[EFloat::err]{err}{}`(err) {
    `\refcode{Store high-precision reference value in EFloat}{}`
}
\end{lstlisting}

\begin{lstlisting}
`\initcode{EFloat Private Data}{=}\initnext{EFloatPrivateData}`
float `\initvar[EFloat::v]{v}{}`;
float `\initvar[EFloat::err]{err}{}`;
\end{lstlisting}

\begin{lstlisting}
`\refcode{EFloat Private Data}{+=}\lastcode{EFloatPrivateData}`
#ifndef NDEBUG
long double `\initvar[EFloat::ld]{ld}{}`;
#endif // NDEBUG
\end{lstlisting}

\begin{lstlisting}
`\refcode{EFloat Public Methods}{+=}\lastnext{EFloatPublicMethods}`
float `\initvar{UpperBound}{}`() const { return `\refvar{NextFloatUp}{}`(`\refvar[EFloat::v]{v}{}` + `\refvar[EFloat::err]{err}{}`); }
float `\initvar{LowerBound}{}`() const { return `\refvar{NextFloatDown}{}`(`\refvar[EFloat::v]{v}{}` - `\refvar[EFloat::err]{err}{}`); }
\end{lstlisting}

\subsection{稳定的三角形相交}\label{sub:稳定的三角形相交}

\subsection{定界交点误差}\label{sub:定界交点误差}