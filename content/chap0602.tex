\section{投影相机模型}\label{sec:相机模型}

三维计算机图形学中的一个基本问题是我们以什么样的视角去观察物体：如何将三维场景投射到二维图像上进行显示。
大多数的经典方法都可以用$4 \time 4$的投影变换矩阵来表达。
因此，我们将引入一个可投影的相机类，即ProjectiveCamera，然后在此基础上定义两个相机模型。
第一个模型实现了正交投影，另一个模型实现了透视投影--两种经典且广泛使用的投影。

\begin{lstlisting}
`\initcode{Camera Declarations}{=}\initnext{CameraDeclarations}`
class `\initvar{ProjectiveCamera}{}` : public `\refvar{Camera}{}` {
public:
    `\refcode{ProjectiveCamera Public Methods}{}`
protected:
    `\refcode{ProjectiveCamera Protected Data}{}`
};
\end{lstlisting}

还有三个坐标系（包含在图6.1中）对定义和讨论投影相机很有用。

屏幕空间。屏幕空间被定义在胶片平面上。
摄影机将摄影空间中的物体投射到胶片平面上；屏幕窗口内的部分在生成的图像中是可见的。
屏幕空间的深度值从0到1，分别对应于近处和远处剪裁平面的点。
注意，虽然这被称为 "屏幕"空间，但它仍然是一个三维坐标系，因为数值是有意义的。

规范化设备坐标（Normalized device coordinate NDC）空间。
这是被渲染的实际图像的坐标系统。在和，这个空间的范围从(0, 0)到 (1, 1)，其中(0, 0)是图像的左上角。
深度值与屏幕空间中的相同，通过线性变换将屏幕空间转换为NDC空间。

光栅空间。这与NDC空间几乎相同，只是和坐标的范围从(0, 0)到屏幕分辨率的范围 。
投影相机使用矩阵在所有这些空间之间进行转换，但具有不寻常成像特性的相机不一定能用矩阵表示所有这些转换。

投影相机使用矩阵在所有这些空间之间进行转换，但具有不寻常成像特征的相机不一定能用矩阵表示所有这些转换。

图6.1: 几个与相机相关的坐标空间通常被用来简化相机的实现。摄像机类持有它们之间的变换。
世界空间中的场景对象由摄像机查看，它位于摄像机空间的原点，并沿轴线指向+Z。
近平面和远平面之间的物体被投射到摄像机空间中的胶片平面上。
胶片平面在栅格空间中，其中和的范围从(0, 0)到(分辨率X，分辨率Y)。
归一化设备坐标（NDC）空间将栅格空间归一化，因此和的范围从(0, 0)到(0, 1) 。

除了相机基类要求的参数外，投影相机还需要投影变换矩阵、图像的屏幕空间范围以及与景深有关的额外参数。景深将在本节末尾描述和实现，它模拟了真实镜头系统中出现的失焦物体的模糊性。
\begin{lstlisting}
`\initcode{ProjectiveCamera Public Methods}{=}\initnext{ProjectiveCamera Public Methods}`
ProjectiveCamera(const AnimatedTransform &CameraToWorld, 
        const Transform &CameraToScreen, const Bounds2f &screenWindow,
        Float shutterOpen, Float shutterClose, Float lensr, Float focald,
        Film *film, const Medium *medium)
    : Camera(CameraToWorld, shutterOpen, shutterClose, film, medium),
      CameraToScreen(CameraToScreen) {
    <<Initialize depth of field parameters>> 
       lensRadius = lensr;
       focalDistance = focald;

    <<Compute projective camera transformations>> 
        <<Compute projective camera screen transformations>> 
            ScreenToRaster = Scale(film->fullResolution.x, 
                                   film->fullResolution.y, 1) *
                Scale(1 / (screenWindow.pMax.x - screenWindow.pMin.x),
                      1 / (screenWindow.pMin.y - screenWindow.pMax.y), 1) *
                Translate(Vector3f(-screenWindow.pMin.x, -screenWindow.pMax.y, 0));
        RasterToScreen = Inverse(ScreenToRaster);

       RasterToCamera = Inverse(CameraToScreen) * RasterToScreen;
}
\end{lstlisting}

ProjectiveCamera的实现将投影变换传递给这里显示的基类构造函数。这个变换给出了相机到屏幕的投影；由此，构造函数可以很容易地计算出其他需要的变换矩阵，以从光栅空间变换到相机空间。

\begin{lstlisting}
<<Compute projective camera transformations>>= 
<<Compute projective camera screen transformations>> 
   ScreenToRaster = Scale(film->fullResolution.x, 
                          film->fullResolution.y, 1) *
       Scale(1 / (screenWindow.pMax.x - screenWindow.pMin.x),
             1 / (screenWindow.pMin.y - screenWindow.pMax.y), 1) *
       Translate(Vector3f(-screenWindow.pMin.x, -screenWindow.pMax.y, 0));
   RasterToScreen = Inverse(ScreenToRaster);

RasterToCamera = Inverse(CameraToScreen) * RasterToScreen;
<<ProjectiveCamera Protected Data>>= 
Transform CameraToScreen, RasterToCamera;
\end{lstlisting}

在构造函数中唯一需要计算的非平凡的变换是屏幕到光栅的投影。
在下面的代码中，请注意变换的组成（从下往上看），我们从屏幕空间的一个点开始，进行平移，使屏幕的左上角位于原点，然后通过屏幕宽度和高度的倒数进行缩放，给我们一个坐标在0到1之间的点（这些是NDC坐标）。
最后，我们用栅格化空间的分辨率进行缩放，这样我们最终就能覆盖整个栅格范围，直至整个栅格分辨率。
这里有一个重要的细节，那就是坐标在这个转换中是倒置的；这是必要的，因为增加的数值在屏幕坐标中是向正方向移动的，但在栅格坐标中是向负方向移动的。

% TODO: add reference
\begin{lstlisting}
<<Compute projective camera screen transformations>>= 
ScreenToRaster = Scale(film->fullResolution.x, 
                       film->fullResolution.y, 1) *
    Scale(1 / (screenWindow.pMax.x - screenWindow.pMin.x),
          1 / (screenWindow.pMin.y - screenWindow.pMax.y), 1) *
    Translate(Vector3f(-screenWindow.pMin.x, -screenWindow.pMax.y, 0));
RasterToScreen = Inverse(ScreenToRaster);
<<ProjectiveCamera Protected Data>>+=  
Transform ScreenToRaster, RasterToScreen;
\end{lstlisting}