\section{kd树加速器}\label{sec:kd树加速器}

\keyindex{二叉空间划分}{binary space partitioning}{}(BSP)树用平面自适应地细分空间。
一个BSP树从包含整个场景的边界框开始。
如果框内图元的数量大于某个阈值，则用平面将该框分为两半。
然后图元和与之重合的任意一半关联，
同时位于两半里的图元就都与它们关联
（相比之下，BVH中划分后每个图元只能分配到两个组中的一个）。

划分过程递归进行，直到结果树中的每个叶子区域都包含足够少的图元或者达到最大深度。
因为划分平面可以放置于整个框内的任意位置，
且3D空间的不同部分可以精确到不同程度，
所以BSP易于处理分布不均的几何体。

BSP树的两个变种是\keyindex{kd树}{kd-tree}{tree树}和\keyindex{八叉树}{octree}{tree树}。
kd树简单地限制划分平面垂直于一个坐标轴；
这让树的遍历和构建都更高效，而在如何划分空间上牺牲一些灵活性。
八叉树每一步用三个垂直于轴的平面同时将该框分为八个区域
（通常在每个方向沿范围中心划分）。

本节中，我们将在类\refvar{KdTreeAccel}{}中为光线相交加速实现一个kd树。
该类源码可在文件\href{https://github.com/mmp/pbrt-v3/tree/master/src/accelerators/kdtreeaccel.h}{\ttfamily accelerators/kdtreeaccel.h}
和\href{https://github.com/mmp/pbrt-v3/tree/master/src/accelerators/kdtreeaccel.cpp}{\ttfamily accelerators/kdtreeaccel.cpp}
中找到。

\begin{lstlisting}
`\initcode{KdTreeAccel Declarations}{=}\initnext{KdTreeAccelDeclarations}`
class `\initvar{KdTreeAccel}{}` : public `\refvar{Aggregate}{}` {
public:
    `\refcode{KdTreeAccel Public Methods}{}`
private:
    `\refcode{KdTreeAccel Private Methods}{}`
    `\refcode{KdTreeAccel Private Data}{}`
};
\end{lstlisting}

除了要保存的图元外，\refvar{KdTreeAccel}{}构造函数
还接收一些参数用于在构建树时指导要作出的决定；
这些参数存于成员变量中（\refvar{isectCost}{}、\refvar{traversalCost}{}、
\refvar{maxPrims}{}、{\ttfamily maxDepth}和\refvar{emptyBonus}{}）留待后用。
见\reffig{4.14}中构建树的图示。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/kdtreesplits.tex}
    \caption{通过沿坐标轴之一递归地划分场景几何边界框来构建kd树。这里，第一次划分沿$x$轴；
    它摆放后使三角形刚好单独在右边区域而其余图元则在左边。
    然后再用轴对齐的划分平面细化若干次左边的区域。
    细化标准的细节——每一步用哪个轴划分空间、沿轴上哪个位置放置平面
    以及何时结束细分——在实践中均会极大影响树的性能。}
    \label{fig:4.14}
\end{figure}

\begin{lstlisting}
`\initcode{KdTreeAccel Method Definitions}{=}\initnext{KdTreeAccelMethodDefinitions}`
`\refvar{KdTreeAccel}{}`::`\refvar{KdTreeAccel}{}`(
        const std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> &p,
        int isectCost, int traversalCost, `\refvar{Float}{}` emptyBonus,
        int maxPrims, int maxDepth)
    : `\refvar{isectCost}{}`(isectCost), `\refvar{traversalCost}{}`(traversalCost),
      `\refvar{maxPrims}{}`(maxPrims), `\refvar{emptyBonus}{}`(emptyBonus), `\refvar[KdTreeAccel::primitives]{primitives}{}`(p) {
    `\refcode{Build kd-tree for accelerator}{}`
}
\end{lstlisting}

\begin{lstlisting}
`\initcode{KdTreeAccel Private Data}{=}\initnext{KdTreeAccelPrivateData}`
const int `\initvar{isectCost}{}`, `\initvar{traversalCost}{}`, `\initvar{maxPrims}{}`;
const `\refvar{Float}{}` `\initvar{emptyBonus}{}`;
std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> `\initvar[KdTreeAccel::primitives]{primitives}{}`;
\end{lstlisting}

\subsection{树状表示}\label{sub:树状表示}
kd树是二叉树，每个内部节点总是有两个孩子且树的叶子存有与之重合的图元。
每个内部节点必须提供三块信息的访问渠道：
\begin{itemize}
    \item 划分轴：该节点划分了$x,y$和$z$中的哪一个轴；
    \item 划分位置：划分平面沿该轴的位置；
    \item 孩子：关于如何到达其下两个子节点的信息。
\end{itemize}
每个叶子节点只需要记录哪个图元与之重合。

为了保证所有内部节点和许多叶子节点只用8字节内存
（假设\refvar{Float}{}占4字节）而麻烦一下是值得的，
因为这样做保证了八个节点契合一个64字节的缓存行。
因为树中经常有许多节点且每条光线通常都要访问许多节点，
最小化节点表示的大小能极大提高缓存性能。
我们最初的实现使用了16字节节点表示；
当我们把大小减少到8字节时我们得到了几乎20\%的提速。

叶子和内部节点都用下面的结构体\refvar{KdAccelNode}{}表示。
每个{\ttfamily union}成员后的注释都说明了特定域是用于内部节点、叶子节点还是两者都是。
\begin{lstlisting}
`\initcode{KdTreeAccel Local Declarations}{=}\initnext{KdTreeAccelLocalDeclarations}`
struct `\initvar{KdAccelNode}{}` {
    `\refcode{KdAccelNode Methods}{}`
    union {
        `\refvar{Float}{}` `\initvar[KdAccelNode::split]{split}{}`;                  // Interior
        int `\initvar{onePrimitive}{}`;             // Leaf
        int `\initvar{primitiveIndicesOffset}{}`;   // Leaf
    };
    union {
        int `\initvar[KdAccelNode::flags]{flags}{}`;         // Both
        int `\initvar{nPrims}{}`;        // Leaf
        int `\initvar{aboveChild}{}`;    // Interior
    };
};
\end{lstlisting}

变量\refvar{KdAccelNode::flags}{}的低两位用于区分用$x,y$和$z$划分的内部节点
（这些数位分别取值0,1和2）以及叶子节点（这些数位取值3）。
在8字节中保存叶子节点相对简单：\refvar{KdAccelNode::flags}{}的低2位
用于表示这是一个叶子，\refvar[nPrims]{KdAccelNode::nPrims}{}的高30位
可用于记录有多少个图元与之重合。
然后，如果只有一个图元与\refvar{KdAccelNode}{}叶子重合，
则指向数组\refvar{KdTreeAccel::primitives}{}
的整数索引会指出该\refvar{Primitive}{}。如果重合的图元多于一个，
则它们的索引保存于\refvar[primitiveIndices]{KdTreeAccel::primitiveIndices}{}的一段中。
该叶子第一个索引的偏移量存于\refvar[primitiveIndicesOffset]{KdAccelNode::primitiveIndicesOffset}{}且后面直接跟着剩下的索引。
\begin{lstlisting}
`\refcode{KdTreeAccel Private Data}{+=}\lastnext{KdTreeAccelPrivateData}`
std::vector<int> `\initvar{primitiveIndices}{}`;
\end{lstlisting}

叶子节点很容易初始化，不过我们要注意细节，
因为\refvar[KdAccelNode::flags]{flags}{}和\refvar{nPrims}{}共享同一存储；
我们需要注意在初始化其中一个时不要搞乱了另一个。
此外，在保存图元数量前必须向左移两位，
这样\refvar{KdAccelNode::flags}{}的低两位可以都设为1以表示这是一个叶子节点。
\begin{lstlisting}
`\refcode{KdTreeAccel Method Definitions}{+=}\lastnext{KdTreeAccelMethodDefinitions}`
void `\refvar{KdAccelNode}{}`::`\initvar[KdAccelNode::InitLeaf]{InitLeaf}{}`(int *primNums, int np,
        std::vector<int> *primitiveIndices) {
    `\refvar[KdAccelNode::flags]{flags}{}` = 3;
    `\refvar{nPrims}{}` |= (np << 2);
    `\refcode{Store primitive ids for leaf node}{}`
}
\end{lstlisting}