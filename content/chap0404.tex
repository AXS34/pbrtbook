\section{kd树加速器}\label{sec:kd树加速器}

\keyindex{二叉空间划分}{binary space partitioning}{}(BSP)树用平面自适应地细分空间。
一个BSP树从包含整个场景的边界框开始。
如果框内图元的数量大于某个阈值，则用平面将该框分为两半。
然后图元和与之重合的任意一半关联，
同时位于两半里的图元就都与它们关联
（相比之下，BVH中划分后每个图元只能分配到两个组中的一个）。

划分过程递归进行，直到结果树中的每个叶子区域都包含足够少的图元或者达到最大深度。
因为划分平面可以放置于整个框内的任意位置，
且3D空间的不同部分可以精确到不同程度，
所以BSP易于处理分布不均的几何体。

BSP树的两个变种是\keyindex{kd树}{kd-tree}{tree树}和\keyindex{八叉树}{octree}{tree树}。
kd树简单地限制划分平面垂直于一个坐标轴；
这让树的遍历和构建都更高效，而在如何划分空间上牺牲一些灵活性。
八叉树每一步用三个垂直于轴的平面同时将该框分为八个区域
（通常在每个方向沿范围中心划分）。

本节中，我们将在类\refvar{KdTreeAccel}{}中为光线相交加速实现一个kd树。
该类源码可在文件\href{https://github.com/mmp/pbrt-v3/tree/master/src/accelerators/kdtreeaccel.h}{\ttfamily accelerators/kdtreeaccel.h}
和\href{https://github.com/mmp/pbrt-v3/tree/master/src/accelerators/kdtreeaccel.cpp}{\ttfamily accelerators/kdtreeaccel.cpp}
中找到。

\begin{lstlisting}
`\initcode{KdTreeAccel Declarations}{=}\initnext{KdTreeAccelDeclarations}`
class `\initvar{KdTreeAccel}{}` : public `\refvar{Aggregate}{}` {
public:
    `\refcode{KdTreeAccel Public Methods}{}`
private:
    `\refcode{KdTreeAccel Private Methods}{}`
    `\refcode{KdTreeAccel Private Data}{}`
};
\end{lstlisting}

除了要保存的图元外，\refvar{KdTreeAccel}{}构造函数
还接收一些参数用于在构建树时指导要作出的决定；
这些参数存于成员变量中（\refvar{isectCost}{}、\refvar{traversalCost}{}、
\refvar{maxPrims}{}、{\ttfamily maxDepth}和\refvar{emptyBonus}{}）留待后用。
见\reffig{4.14}中构建树的图示。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/kdtreesplits.tex}
    \caption{通过沿坐标轴之一递归地划分场景几何边界框来构建kd树。这里，第一次划分沿$x$轴；
    它摆放后使三角形刚好单独在右边区域而其余图元则在左边。
    然后再用轴对齐的划分平面细化若干次左边的区域。
    细化标准的细节——每一步用哪个轴划分空间、沿轴上哪个位置放置平面
    以及何时结束细分——在实践中均会极大影响树的性能。}
    \label{fig:4.14}
\end{figure}

\begin{lstlisting}
`\initcode{KdTreeAccel Method Definitions}{=}\initnext{KdTreeAccelMethodDefinitions}`
`\refvar{KdTreeAccel}{}`::`\refvar{KdTreeAccel}{}`(
        const std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> &p,
        int isectCost, int traversalCost, `\refvar{Float}{}` emptyBonus,
        int maxPrims, int maxDepth)
    : `\refvar{isectCost}{}`(isectCost), `\refvar{traversalCost}{}`(traversalCost),
      `\refvar{maxPrims}{}`(maxPrims), `\refvar{emptyBonus}{}`(emptyBonus), `\refvar[KdTreeAccel::primitives]{primitives}{}`(p) {
    `\refcode{Build kd-tree for accelerator}{}`
}
\end{lstlisting}

\begin{lstlisting}
`\initcode{KdTreeAccel Private Data}{=}\initnext{KdTreeAccelPrivateData}`
const int `\initvar{isectCost}{}`, `\initvar{traversalCost}{}`, `\initvar{maxPrims}{}`;
const `\refvar{Float}{}` `\initvar{emptyBonus}{}`;
std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> `\initvar[KdTreeAccel::primitives]{primitives}{}`;
\end{lstlisting}

\subsection{树状表示}\label{sub:树状表示}
kd树是二叉树，每个内部节点总是有两个孩子且树的叶子存有与之重合的图元。
每个内部节点必须提供三块信息的访问渠道：
\begin{itemize}
    \item 划分轴：该节点划分了$x,y$和$z$中的哪一个轴；
    \item 划分位置：划分平面沿该轴的位置；
    \item 孩子：关于如何到达其下两个子节点的信息。
\end{itemize}
每个叶子节点只需要记录哪个图元与之重合。

为了保证所有内部节点和许多叶子节点只用8字节内存
（假设\refvar{Float}{}占4字节）而麻烦一下是值得的，
因为这样做保证了八个节点契合一个64字节的缓存行。
因为树中经常有许多节点且每条光线通常都要访问许多节点，
最小化节点表示的大小能极大提高缓存性能。
我们最初的实现使用了16字节节点表示；
当我们把大小减少到8字节时我们得到了几乎20\%的提速。

叶子和内部节点都用下面的结构体\refvar{KdAccelNode}{}表示。
每个{\ttfamily union}成员后的注释都说明了特定域是用于内部节点、叶子节点还是两者都是。
\begin{lstlisting}
`\initcode{KdTreeAccel Local Declarations}{=}\initnext{KdTreeAccelLocalDeclarations}`
struct `\initvar{KdAccelNode}{}` {
    `\refcode{KdAccelNode Methods}{}`
    union {
        `\refvar{Float}{}` `\initvar[KdAccelNode::split]{split}{}`;                  // Interior
        int `\initvar{onePrimitive}{}`;             // Leaf
        int `\initvar{primitiveIndicesOffset}{}`;   // Leaf
    };
    union {
        int `\initvar[KdAccelNode::flags]{flags}{}`;         // Both
        int `\initvar{nPrims}{}`;        // Leaf
        int `\initvar{aboveChild}{}`;    // Interior
    };
};
\end{lstlisting}

变量\refvar{KdAccelNode::flags}{}的低两位用于区分用$x,y$和$z$划分的内部节点
（这些数位分别取值0,1和2）以及叶子节点（这些数位取值3）。
在8字节中保存叶子节点相对简单：\refvar{KdAccelNode::flags}{}的低2位
用于表示这是一个叶子，\refvar[nPrims]{KdAccelNode::nPrims}{}的高30位
可用于记录有多少个图元与之重合。
然后，如果只有一个图元与\refvar{KdAccelNode}{}叶子重合，
则指向数组\refvar{KdTreeAccel::primitives}{}
的整数索引会指出该\refvar{Primitive}{}。如果重合的图元多于一个，
则它们的索引保存于\refvar[primitiveIndices]{KdTreeAccel::primitiveIndices}{}的一段中。
该叶子第一个索引的偏移量存于\refvar[primitiveIndicesOffset]{KdAccelNode::primitiveIndicesOffset}{}且后面直接跟着剩下的索引。
\begin{lstlisting}
`\refcode{KdTreeAccel Private Data}{+=}\lastnext{KdTreeAccelPrivateData}`
std::vector<int> `\initvar{primitiveIndices}{}`;
\end{lstlisting}

叶子节点很容易初始化，不过我们要注意细节，
因为\refvar[KdAccelNode::flags]{flags}{}和\refvar{nPrims}{}共享同一存储；
我们需要注意在初始化其中一个时不要搞乱了另一个。
此外，在保存图元数量前必须向左移两位，
这样\refvar{KdAccelNode::flags}{}的低两位可以都设为1以表示这是一个叶子节点。
\begin{lstlisting}
`\refcode{KdTreeAccel Method Definitions}{+=}\lastnext{KdTreeAccelMethodDefinitions}`
void `\refvar{KdAccelNode}{}`::`\initvar[KdAccelNode::InitLeaf]{InitLeaf}{}`(int *primNums, int np,
        std::vector<int> *primitiveIndices) {
    `\refvar[KdAccelNode::flags]{flags}{}` = 3;
    `\refvar{nPrims}{}` |= (np << 2);
    `\refcode{Store primitive ids for leaf node}{}`
}
\end{lstlisting}

对于有零或一个重合图元的叶子节点，
因为有\refvar[onePrimitive]{KdAccelNode::onePrimitive}{}
域了，所以不再需要额外分配内存。
对于有多个重合图元的情况，则在数组{\ttfamily primitiveIndices}中分配存储。
\begin{lstlisting}
`\initcode{Store primitive ids for leaf node}{=}`
if (np == 0)
    `\refvar{onePrimitive}{}` = 0;
else if (np == 1)
    `\refvar{onePrimitive}{}` = primNums[0];
else {
    `\refvar{primitiveIndicesOffset}{}` = primitiveIndices->size();
    for (int i = 0; i < np; ++i)
        primitiveIndices->push_back(primNums[i]);
}
\end{lstlisting}

让内部节点减少到8字节也相当简单。
一个\refvar{Float}{}（当\refvar{Float}{}定义为{\ttfamily float}时其大小为32位）
保存了节点沿所选划分轴分割空间的位置，并且如之前所述，
\refvar{KdAccelNode::flags}{}低两位用于记录该节点是沿哪个轴划分的。
剩下的就是存储足够的信息使我们遍历树时能找到该节点的两个孩子。

我们排布节点的方式是只存储一个孩子指针，而不是存储两个指针或偏移量：
所有节点都分配到单个连续内存块，
内部节点的对应划分平面下方空间的孩子在数组中的保存位置总是紧跟其父亲
（通过在内存中保持至少一个孩子挨着其父亲，这样的排布也提高了缓存性能）。
另一个对应于划分平面上方的孩子，则在数组其他某处出现；
单个整数偏移量\refvar[aboveChild]{KdAccelNode::aboveChild}{}保存了它在节点数组中的位置。
该表示和\refsub{为遍历而压实的BVH}中BVH节点用的类似。

有了所有这些约定，初始化内部节点的代码就很简单了。
就像方法\refvar[KdAccelNode::InitLeaf]{InitLeaf}{()}
那样，在设置\refvar{aboveChild}{}前为\refvar[KdAccelNode::flags]{flags}{}赋值、
计算移位的\refvar{aboveChild}{}逻辑或值很重要，
这样才不会搞乱保存在\refvar[KdAccelNode::flags]{flags}{}中的数位。
\begin{lstlisting}
`\initcode{KdAccelNode Methods}{=}\initnext{KdAccelNodeMethods}`
void `\initvar[KdAccelNode::InitInterior]{InitInterior}{}`(int axis, int ac, `\refvar{Float}{}` s) {
    `\refvar[KdAccelNode::split]{split}{}` = s;
    `\refvar[KdAccelNode::flags]{flags}{}` = axis;
    `\refvar{aboveChild}{}` |= (ac << 2);
}
\end{lstlisting}

最后，我们将提供一些方法从节点中提取各种值，
这样调用者就不需要了解其内存表示的细节了。
\begin{lstlisting}
`\refcode{KdAccelNode Methods}{+=}\lastcode{KdAccelNodeMethods}`
`\refvar{Float}{}` `\initvar{SplitPos}{()}` const { return `\refvar[KdAccelNode::split]{split}{}`; }
int `\initvar[KdAccelNode::nPrimitives]{nPrimitives}{()}` const { return `\refvar{nPrims}{}` >> 2; }
int `\initvar[KdAccelNode::SplitAxis]{SplitAxis}{()}` const { return `\refvar[KdAccelNode::flags]{flags}{}` & 3; }
bool `\initvar{IsLeaf}{()}` const { return (`\refvar[KdAccelNode::flags]{flags}{}` & 3) == 3; }
int `\initvar{AboveChild}{()}` const { return `\refvar{aboveChild}{}` >> 2; }
\end{lstlisting}

\subsection{树的构建}\label{sub:树的构建}
