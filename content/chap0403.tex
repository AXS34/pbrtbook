\section{包围盒层次}\label{sec:包围盒层次}

\keyindex{包围盒层次}{bounding volume hierarchy}{}(BVH)是一种
基于图元细分的光线相交加速方法，把图元划分为不相交集合的层次
（相反，空间细分一般把空间划分为不相交集合的层次）。
\reffig{4.2}展示了简单场景的包围盒层次\sidenote{译者注：包围盒是边界框的近义词。}。
图元存于\keyindex{叶子}{leaf}{}中，只要它不与节点的边界相交，
该节点下的子树就可以跳过。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/Primitivesandhierarchy.tex}
    \caption{简单场景的包围盒层次。(a)一小部分图元，边界框用虚线表示。
        图元基于邻近度聚合；这里，球体和等边三角形在被框住整个场景的边界框
        围住之前都被另一个边界框包围了（都用实线表示）。(b)相应的包围盒层次。
        根节点持有整个场景。这里它有两个孩子，一个保存包围了球体和等边三角形的边界框
        （又把这些图元作为其孩子），另一个保存持有瘦三角形的边界框。}
    \label{fig:4.2}
\end{figure}

图元细分的一个性质是每个图元只在层次中出现一次。
相反，一个图元可能与空间细分的多个空间区域重合，
因此在光线穿过它们时要多次测试相交
\footnote{\protect\keyindex{邮箱}{mailboxing}{}技术可用于
    让使用空间细分的加速器避免这样的多次相交，但它的实现在存在多进程时会很棘手。
    “扩展阅读”一节有关于邮箱的更多信息。}。
该性质还意味着表示图元细分层次所需的内存量是有界的。
对于每个叶子中保存单个图元的二叉BVH，节点总数为$2n-1$，其中$n$是图元数量。
有$n$个叶子节点和$n-1$个内部节点
\sidenote{译者注：这些结论利用了二叉BVH的前提：每个节点要么是叶子节点，要么是有两个孩子的内部节点。}。
如果叶子保存了多个图元，则需要的节点更少。

构建BVH比kd树更高效，kd树分发光线相交测试通常比BVH稍快但构建时间长得多。
另一方面，BVH通常数值更稳定，比起kd树更不容易因为舍入误差错过相交。

BVH加速器{\refvar{BVHAccel}{}}定义在\href{https://github.com/mmp/pbrt-v3/tree/master/src/accelerators/bvh.h}{\ttfamily accelerators/bvh.h}
和\href{https://github.com/mmp/pbrt-v3/tree/master/src/accelerators/bvh.cpp}{\ttfamily accelerators/bvh.cpp}
中。除了要保存的图元以及任何叶子节点中的最大图元数目，
其构造函数还接收一个描述当划分图元以构建树时要用四个算法中哪一个的枚举值。
应该用默认值\refvar{SAH}{}，它表示\refsub{表面积启发法}讨论的基于“表面积启发法”的算法。
另一个是\refsub{线性包围盒层次}讨论的\refvar{HLBVH}{}，
它能更高效地构造（且更易并行化），但建立的树不如\refvar{SAH}{}高效。
剩下的两种方法使用的计算量甚至更少，但创建的树的质量非常低。
\begin{lstlisting}
`\initcode{BVHAccel Public Types}{=}`
enum class `\initvar{SplitMethod}{}` { `\initvar{SAH}{}`, `\initvar{HLBVH}{}`, `\initvar{Middle}{}`, `\initvar{EqualCounts}{}` };
\end{lstlisting}
\begin{lstlisting}
`\initcode{BVHAccel Method Definitions}{=}\initnext{BVHAccelMethodDefinitions}`
`\initvar{BVHAccel}{}`::`\refvar{BVHAccel}{}`(const std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> &p,
         int maxPrimsInNode, `\refvar{SplitMethod}{}` splitMethod)
     : `\refvar{maxPrimsInNode}{}`(std::min(255, maxPrimsInNode)), `\refvar[BVHAccel::primitives]{primitives}{}`(p),
       `\refvar{splitMethod}{}`(splitMethod) {
    if (primitives.size() == 0)
        return;
    `\refcode{Build BVH from primitives}{}`
}
\end{lstlisting}
\begin{lstlisting}
`\initcode{BVHAccel Private Data}{=}\initnext{BVHAccelPrivateData}`
const int `\initvar{maxPrimsInNode}{}`;
const `\refvar{SplitMethod}{}` `\initvar{splitMethod}{}`;
std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> `\initvar[BVHAccel::primitives]{primitives}{}`;
\end{lstlisting}

\subsection{BVH构建}\label{sub:BVH构建}
这里的实现中构建BVH有三个阶段。
首先，计算关于每个图元的边界信息并保存到将于树构建期间使用的数组中。
接着，用选择的编码于\refvar{SplitMethod}{}的算法构建树。
结果是\keyindex{二叉树}{binary tree}{}每个内部节点
都有指针指向其孩子且每个叶子节点都有指向一个或多个图元的引用。
最后，该树转化为更紧实（且因此更高效）的无指针表示以供渲染时使用
（虽然在构建树期间直接计算无指针表示也可以，但用该方法实现更简单）。
\begin{lstlisting}
`\initcode{Build BVH from primitives}{=}`
`\refcode{Initialize primitiveInfo array for primitives}{}`
`\refcode{Build BVH tree for primitives using primitiveInfo}{}`
`\refcode{Compute representation of depth-first traversal of BVH tree}{}`
\end{lstlisting}

对于每个要存于BVH的图元，我们在结构体\refvar{BVHPrimitiveInfo}{}的一个实例中
存储其边界框的形心、完整边界框以及它在\refvar{primitives}{}数组中的索引。
\begin{lstlisting}
`\initcode{Initialize primitiveInfo array for primitives}{=}`
std::vector<`\refvar{BVHPrimitiveInfo}{}`> primitiveInfo(`\refvar[BVHAccel::primitives]{primitives}{}`.size());
for (size_t i = 0; i < `\refvar[BVHAccel::primitives]{primitives}{}`.size(); ++i)
    primitiveInfo[i] = { i, `\refvar[BVHAccel::primitives]{primitives}{}`[i]->`\refvar[Primitive::WorldBound]{WorldBound}{}`() };
\end{lstlisting}
\begin{lstlisting}
`\initcode{BVHAccel Local Declarations}{=}\initnext{BVHAccelLocalDeclarations}`
struct `\initvar{BVHPrimitiveInfo}{}` {
    `\refvar{BVHPrimitiveInfo}{}`(size_t primitiveNumber, const `\refvar{Bounds3f}{}` &bounds)
        : `\refvar{primitiveNumber}{}`(primitiveNumber), `\refvar[BVHPrimitiveInfo::bounds]{bounds}{}`(bounds),
          `\refvar{centroid}{}`(.5f * bounds.`\refvar{pMin}{}` + .5f * bounds.`\refvar{pMax}{}`) { }
    size_t `\initvar{primitiveNumber}{}`;
    `\refvar{Bounds3f}{}` `\initvar[BVHPrimitiveInfo::bounds]{bounds}{}`;
    `\refvar{Point3f}{}` `\initvar{centroid}{}`;
};
\end{lstlisting}

现在可以开始层次构建了。如果选择HLBVH构建算法，则调用\refvar{HLBVHBuild}{()}
构建树。其他三种构建算法都由\refvar{recursiveBuild}{()}负责。
初始调用这些函数时传递了所有要存于树中的图元。
它们返回一个指向树根的指针，用结构体\refvar{BVHBuildNode}{}表示。
树节点应该用提供的\refvar{MemoryArena}{}分配内存，
创建的总数应存于{\ttfamily *totalNodes}中。

树构建过程的一个重要副作用是通过参数{\ttfamily orderedPrims}返回指向图元的新指针数组；
该数组保存了有序的图元这样叶子节点的图元在数组中占有连续的范围。
在树构建后它与原始的\refvar[BVHAccel::primitives]{primitives}{}数组交换。
\begin{lstlisting}
`\initcode{Build BVH tree for primitives using primitiveInfo}{=}`
`\refvar{MemoryArena}{}` arena(1024 * 1024);
int totalNodes = 0;
std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> orderedPrims;
`\refvar{BVHBuildNode}{}` *root;
if (splitMethod == `\refvar{SplitMethod}{}`::`\refvar{HLBVH}{}`)
    root = `\refvar{HLBVHBuild}{}`(arena, primitiveInfo, &totalNodes, orderedPrims);
else
    root = `\refvar{recursiveBuild}{}`(arena, primitiveInfo, 0, `\refvar[BVHAccel::primitives]{primitives}{}`.size(),
                          &totalNodes, orderedPrims);
`\refvar[BVHAccel::primitives]{primitives}{}`.swap(orderedPrims);
\end{lstlisting}

每个\refvar{BVHBuildNode}{}表示一个BVH节点。
所有节点存储一个\refvar{Bounds3f}{}以表示该节点下所有孩子的边界。
每个内部节点在\refvar[BVHBuildNode::children]{children}{}中存有指向其两个孩子的指针。
内部节点也记录图元沿哪个坐标轴划分分给它们的两个孩子；
该信息用于提高遍历算法的性能。
叶子节点需要记录哪个或哪些图元保存在它们中；
数组\refvar{BVHAccel::primitives}{}中从偏移量\refvar{firstPrimOffset}{}起
直到但不包括{\ttfamily\refvar{firstPrimOffset}{}+\refvar{nPrimitives}{}}的元素是叶子中的元素
（因此需要记录图元数组，这样就可以利用该表示，
而不是例如在每个叶子节点中保存一个大小可变的图元索引数组）。
\begin{lstlisting}
`\refcode{BVHAccel Local Declarations}{+=}\lastnext{BVHAccelLocalDeclarations}`
struct `\initvar{BVHBuildNode}{}` {
    `\refcode{BVHBuildNode Public Methods}{}`
    `\refvar{Bounds3f}{}` `\initvar[BVHBuildNode::bounds]{bounds}{}`;
    `\refvar{BVHBuildNode}{}` *`\initvar[BVHBuildNode::children]{children}{}`[2];
    int `\initvar{splitAxis}{}`, `\initvar{firstPrimOffset}{}`, `\initvar{nPrimitives}{}`;
};
\end{lstlisting}

我们将通过其孩子指针是否有值{\ttfamily nullptr}来分别区分叶子和内部节点。
\begin{lstlisting}
`\initcode{BVHBuildNode Public Methods}{=}\initnext{BVHBuildNodePublicMethods}`
void `\initvar{InitLeaf}{}`(int first, int n, const `\refvar{Bounds3f}{}` &b) {
    `\refvar{firstPrimOffset}{}` = first;
    `\refvar{nPrimitives}{}` = n;
    `\refvar[BVHBuildNode::bounds]{bounds}{}` = b;
    `\refvar[BVHBuildNode::children]{children}{}`[0] = `\refvar[BVHBuildNode::children]{children}{}`[1] = nullptr;
}
\end{lstlisting}

方法\refvar{InitInterior}{()}要求已创建两个孩子节点，这样它们的指针才能传入。
该要求让计算内部节点的边界更加容易了，因为孩子的边界可以立刻获得。
\begin{lstlisting}
`\refcode{BVHBuildNode Public Methods}{+=}\lastcode{BVHBuildNodePublicMethods}`
void `\initvar{InitInterior}{}`(int axis, `\refvar{BVHBuildNode}{}` *c0, `\refvar{BVHBuildNode}{}` *c1) {
    `\refvar[BVHBuildNode::children]{children}{}`[0] = c0;
    `\refvar[BVHBuildNode::children]{children}{}`[1] = c1;
    `\refvar[BVHBuildNode::bounds]{bounds}{}` = `\refvar[Union2]{Union}{}`(c0->`\refvar[BVHBuildNode::bounds]{bounds}{}`, c1->`\refvar[BVHBuildNode::bounds]{bounds}{}`);
    `\refvar{splitAxis}{}` = axis;
    `\refvar{nPrimitives}{}` = 0;
}
\end{lstlisting}

除了用于分配节点和\refvar{BVHPrimitiveInfo}{}结构体数组的\refvar{MemoryArena}{}外，\linebreak
\refvar{recursiveBuild}{()}接收范围参数{\ttfamily[start,end)}。
它负责为从{\ttfamily primitiveInfo [start]}直到并包括{\ttfamily primitiveInfo[end-1]}的
范围表示的图元子集返回一个BVH。
如果该范围只含有单个图元，则递归触底并创建一个叶子节点。
否则，该方法用划分算法之一来划分数组该范围内的元素并相应地重新排列它们，
这样范围{\ttfamily[start,mid)}和{\ttfamily[mid,end)}表示分开的子集。
如果划分成功，则这两个图元集合又传入将会为当前节点的两个孩子返回节点指针的递归调用。

{\ttfamily totalNodes}跟踪已创建的BVH节点总数；
利用该数目使得之后可以分配数目恰好正确的更紧实的\refvar{LinearBVHNode}{}。
最终，数组{\ttfamily orderedPrims}用于保存图元引用就像图元存于树的叶子节点一样。
该数组初始化为空；当创建一个叶子节点时，\refvar{recursiveBuild}{()}把
与之重合的图元添加到数列末尾，让叶子节点可以只存储对该数组的偏移量以及
表示与之重合的图元集的图元数量。
回想当完成树构建时，用这里创建的有序图元数组代替\refvar{BVHAccel::primitives}{}。
\begin{lstlisting}
`\refcode{BVHAccel Method Definitions}{+=}\lastnext{BVHAccelMethodDefinitions}`
`\refvar{BVHBuildNode}{}` *`\refvar{BVHAccel}{}`::`\initvar{recursiveBuild}{}`(`\refvar{MemoryArena}{}` &arena,
        std::vector<`\refvar{BVHPrimitiveInfo}{}`> &primitiveInfo, int start,
        int end, int *totalNodes,
        std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> &orderedPrims) {
    `\refvar{BVHBuildNode}{}` *node = arena.`\refvar[MemoryArena:Alloc2]{Alloc}{}`<`\refvar{BVHBuildNode}{}`>();
    (*totalNodes)++;
    `\refcode{Compute bounds of all primitives in BVH node}{}`
    int nPrimitives = end - start;
    if (nPrimitives == 1) {
        `\refcode{Create leaf BVHBuildNode}{}`
    } else {
        `\refcode{Compute bound of primitive centroids, choose split dimension dim}{}`
        `\refcode{Partition primitives into two sets and build children}{}`
    }
    return node;
}
\end{lstlisting}
\begin{lstlisting}
`\initcode{Compute bounds of all primitives in BVH node}{=}`
`\refvar{Bounds3f}{}` bounds;
for (int i = start; i < end; ++i)
    bounds = `\refvar[Union2]{Union}{}`(bounds, primitiveInfo[i].`\refvar[BVHPrimitiveInfo::bounds]{bounds}{}`);
\end{lstlisting}

在叶子节点处，与该叶子重合的图元被添到{\ttfamily orderedPrims}数组末尾并初始化一个叶子节点对象。
\begin{lstlisting}
`\initcode{Create leaf BVHBuildNode}{=}`
int firstPrimOffset = orderedPrims.size();
for (int i = start; i < end; ++i) {
    int primNum = primitiveInfo[i].`\refvar{primitiveNumber}{}`;
    orderedPrims.push_back(`\refvar[BVHAccel::primitives]{primitives}{}`[primNum]);
}
node->`\refvar{InitLeaf}{}`(firstPrimOffset, nPrimitives, bounds);
return node;
\end{lstlisting}

对于内部节点，一组图元必须在两个子树之间划分。
给定$n$个图元，有$2^{n-1}-1$种\sidenote{译者注：原文误写为$2(n-1)-2$，已修正。}
可能的方法将它们划分到两个非空组。
实际中构建BVH时，一般考虑沿一个坐标轴划分，这意味着大约有$3n$个候选划分
（沿每个轴方向，每个图元可能放到第一分区或第二分区）。

这里我们就选择三个坐标轴的一个用来划分图元。
当为当前图元集合投影边界框形心时，我们选择有最大范围的轴
（另一种是尝试所有三个轴并选择给出最好结果的那个，但实际中本方法更好）。
该方法在许多场景下给出良好划分；\reffig{4.3}说明了该策略。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/BVHchoosesplitaxis.tex}
    \caption{选择沿哪个轴划分图元。\protect\refvar{BVHAccel}{}基于
        图元边界框形心在哪个轴有最大范围来选择划分图元所沿的轴。
        这里在二维中，它们沿$y$轴的范围最大（轴上的实心点），所以图元会在$y$上划分。}
    \label{fig:4.3}
\end{figure}

这里划分的一般目标是选择图元的一个划分使得
得到的两个图元集合的边界框没有太多重合——
如果有大量重合则在遍历树时它会更频繁地需要遍历两个子树，
比起本应可以更高效剪除一些图元它需要更多计算量。
待会儿在讨论表面积启发法时会更严谨地表述该求取高效图元划分的思想。
\begin{lstlisting}
`\initcode{Compute bound of primitive centroids, choose split dimension dim}{=}`
`\refvar{Bounds3f}{}` centroidBounds;
for (int i = start; i < end; ++i)
    centroidBounds = `\refvar[Union2]{Union}{}`(centroidBounds, primitiveInfo[i].`\refvar{centroid}{}`);
int dim = centroidBounds.`\refvar{MaximumExtent}{}`();
\end{lstlisting}

如果所有形心点都在同一位置（即形心边界为零体积），
则递归停止并用该图元创建一个叶子结点；
这里没有划分方法能对那种（非常）情况有效。
否则用选择的方法划分图元并传入两个对\refvar{recursiveBuild}{()}的递归调用。
\begin{lstlisting}
`\initcode{Partition primitives into two sets and build children}{=}`
int mid = (start + end) / 2;
if (centroidBounds.`\refvar{pMax}{}`[dim] == centroidBounds.`\refvar{pMin}{}`[dim]) {
    `\refcode{Create leaf BVHBuildNode}{}`
} else {
    `\refcode{Partition primitives based on splitMethod}{}`
    node->`\refvar{InitInterior}{}`(dim,
                       `\refvar{recursiveBuild}{}`(arena, primitiveInfo, start, mid,
                                      totalNodes, orderedPrims),
                       `\refvar{recursiveBuild}{}`(arena, primitiveInfo, mid, end,
                                      totalNodes, orderedPrims));
}
\end{lstlisting}

代码片\refcode{Partition primitives based on splitMethod}{}只是用
\refvar[splitMethod]{BVHAccel::splitMethod}{}
的值决定该用哪个图元划分方案。接下来的几页将介绍这三个方案。
\begin{lstlisting}
`\initcode{Partition primitives based on splitMethod}{=}`
switch (`\refvar{splitMethod}{}`) {
case `\refvar{SplitMethod}{}`::`\refvar{Middle}{}`: {
    `\refcode{Partition primitives through node's midpoint}{}`
}
case `\refvar{SplitMethod}{}`::`\refvar{EqualCounts}{}`: {
    `\refcode{Partition primitives into equally sized subsets}{}`
    break;
}
case `\refvar{SplitMethod}{}`::`\refvar{SAH}{}`:
default: {
    `\refcode{Partition primitives using approximate SAH}{}`
    break;
}
}
\end{lstlisting}

\refvar{Middle}{}是一个简单的\refvar{SplitMethod}{}，
它首先计算图元形心沿划分轴的中点。
该方法在代码片\refcode{Partition primitives through node's midpoint}{}中实现。
图元按其形心在中点之上还是之下分为两个集合。
该划分用C++标准库函数{\ttfamily std::partition()}很容易完成，
它接收数组中的一系列元素和比较函数，并对数组元素排序使得
对于判定函数而言所有返回{\ttfamily true}的元素都出现在返回{\ttfamily false}的范围之前
\footnote{在调用{\ttfamily std::partition()}时，
注意数组{\ttfamily primitiveInfo}索引的特殊表达式即{\ttfamily \&primitiveInfo[end-1]+1}。
这样写代码有些晦涩的理由。在C和C++程序语言中，
计算数组末尾后下一个元素的指针是合法的，
这样遍历数组元素能持续到当前指针等于末端点。
为此，我们这里想就写成表达式{\ttfamily \&primitiveInfo[end]}。
然而{\ttfamily primitiveInfo}分配为C++的{\ttfamily vector}；
一些{\ttfamily vector}实现在传给其{\ttfamily []}操作符
的偏移量是在数组末端之后时会报运行时错误。
因为我们不会尝试引用数组末端后下一个元素的值而只是想计算其地址，
所以该操作事实上是安全的。
因此我们最终用这里的表达式计算同一地址，并且也满足任何{\ttfamily vector}错误检查。}。
{\ttfamily std::partition()}返回指向第一个对于判定有{\ttfamily false}值的元素的指针，
它转化为对数组{\ttfamily primitiveInfo}的偏移量，这样我们就可以将其传入递归调用。
\reffig{4.4}说明了该方法，包括其有效和无效的情况。

如果图元都有巨大的重叠边界框，则该划分方法可能无法把图元分为两组。
这种情况下，执行往下进入{\ttfamily \refvar{SplitMethod}{}::\refvar{EqualCounts}{}}方法再试一次。
\begin{lstlisting}
`\initcode{Partition primitives through node's midpoint}{=}`
`\refvar{Float}{}` pmid = (centroidBounds.`\refvar{pMin}{}`[dim] + centroidBounds.`\refvar{pMax}{}`[dim]) / 2;
`\refvar{BVHPrimitiveInfo}{}` *midPtr =
    std::partition(&primitiveInfo[start], &primitiveInfo[end-1]+1,
        [dim, pmid](const `\refvar{BVHPrimitiveInfo}{}` &pi) {
            return pi.`\refvar{centroid}{}`[dim] < pmid;
        });
mid = midPtr - &primitiveInfo[0];
if (mid != start && mid != end)
    break;
\end{lstlisting}

当\refvar{splitMethod}{}是{\ttfamily\refvar{SplitMethod}{}::\refvar{EqualCounts}{}}时，
则运行代码片\refcode{Partition primitives into equally sized subsets}{}。
它把图元划分为两个数量相等的子集使得$n$个中前一半的$\displaystyle\frac{n}{2}$个
沿所选轴的形心坐标最小，另一半的则有最大形心坐标值。
尽管该方法有时能起效，但也有\reffig{4.4}(b)效果不好的情况。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/Midpointgoodbadsplit.tex}
    \caption{在一个轴上基于形心中点划分图元。(a)对于一些图元分布，
        例如这里所展示的，沿所选轴（粗蓝线）基于形心中点的划分效果很好。
        (b)对于像这个的分布，中点是次优选项；得到的两个边界框大量重叠。
        (c)如果来自(b)的同一组图元换为用这里展示的线分开，得到的边界框
        更小且根本不会重叠，使渲染时性能更好。}
    \label{fig:4.4}
\end{figure}

该方案也易于调用标准库的{\ttfamily std::nth\_element()}实现。
它接收起点、中点和终点指针以及一个比较函数。
它对数组排序使得中点指针处元素的位置是，如果数组完全排序，
则所有中点之前的元素都比中点元素小且所有后面的元素都比它大。
对于$n$个元素该排序可以在$O(n)$时间内完成，
比完全排序数组的$O(n\log{n})$更高效。
\begin{lstlisting}
`\initcode{Partition primitives into equally sized subsets}{}`
mid = (start + end) / 2;
std::nth_element(&primitiveInfo[start], &primitiveInfo[mid], 
                 &primitiveInfo[end-1]+1,
    [dim](const BVHPrimitiveInfo &a, const BVHPrimitiveInfo &b) { 
        return a.`\refvar{centroid}{}`[dim] < b.`\refvar{centroid}{}`[dim];
    });
\end{lstlisting}

\subsection{表面积启发法}\label{sub:表面积启发法}

\subsection{线性包围盒层次}\label{sub:线性包围盒层次}