\section{包围盒层次}\label{sec:包围盒层次}

\keyindex{包围盒层次}{bounding volume hierarchy}{}(BVH)是一种
基于图元细分的光线相交加速方法，把图元划分为不相交集合的层次
（相反，空间细分一般把空间划分为不相交集合的层次）。
\reffig{4.2}展示了简单场景的包围盒层次\sidenote{译者注：包围盒是边界框的近义词。}。
图元存于\keyindex{叶子}{leaf}{}中，只要它不与节点的边界相交，
该节点下的子树就可以跳过。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/Primitivesandhierarchy.tex}
    \caption{简单场景的包围盒层次。(a)一小部分图元，边界框用虚线表示。
        图元基于邻近度聚合；这里，球体和等边三角形在被框住整个场景的边界框
        围住之前都被另一个边界框包围了（都用实线表示）。(b)相应的包围盒层次。
        根节点持有整个场景。这里它有两个孩子，一个保存包围了球体和等边三角形的边界框
        （又把这些图元作为其孩子），另一个保存持有瘦三角形的边界框。}
    \label{fig:4.2}
\end{figure}

图元细分的一个性质是每个图元只在层次中出现一次。
相反，一个图元可能与空间细分的多个空间区域重合，
因此在光线穿过它们时要多次测试相交
\footnote{\protect\keyindex{邮箱}{mailboxing}{}技术可用于
    让使用空间细分的加速器避免这样的多次相交，但它的实现在存在多进程时会很棘手。
    “扩展阅读”一节有关于邮箱的更多信息。}。
该性质还意味着表示图元细分层次所需的内存量是有界的。
对于每个叶子中保存单个图元的二叉BVH，节点总数为$2n-1$，其中$n$是图元数量。
有$n$个叶子节点和$n-1$个内部节点
\sidenote{译者注：这些结论利用了二叉BVH的前提：每个节点要么是叶子节点，要么是有两个孩子的内部节点。}。
如果叶子保存了多个图元，则需要的节点更少。

构建BVH比kd树更高效，kd树分发光线相交测试通常比BVH稍快但构建时间长得多。
另一方面，BVH通常数值更稳定，比起kd树更不容易因为舍入误差错过相交。

BVH加速器{\refvar{BVHAccel}{}}定义在\href{https://github.com/mmp/pbrt-v3/tree/master/src/accelerators/bvh.h}{\ttfamily accelerators/bvh.h}
和\href{https://github.com/mmp/pbrt-v3/tree/master/src/accelerators/bvh.cpp}{\ttfamily accelerators/bvh.cpp}
中。除了要保存的图元以及任何叶子节点中的最大图元数目，
其构造函数还接收一个描述当划分图元以构建树时要用四个算法中哪一个的枚举值。
应该用默认值\refvar{SAH}{}，它表示\refsub{表面积启发法}讨论的基于“表面积启发法”的算法。
另一个是\refsub{线性包围盒层次}讨论的\refvar{HLBVH}{}，
它能更高效地构造（且更易并行化），但建立的树不如\refvar{SAH}{}高效。
剩下的两种方法使用的计算量甚至更少，但创建的树的质量非常低。
\begin{lstlisting}
`\initcode{BVHAccel Public Types}{=}`
enum class `\initvar{SplitMethod}{}` { `\initvar{SAH}{}`, `\initvar{HLBVH}{}`, `\initvar{Middle}{}`, `\initvar{EqualCounts}{}` };
\end{lstlisting}
\begin{lstlisting}
`\initcode{BVHAccel Method Definitions}{=}\initnext{BVHAccelMethodDefinitions}`
`\initvar{BVHAccel}{}`::`\refvar{BVHAccel}{}`(const std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> &p,
         int maxPrimsInNode, `\refvar{SplitMethod}{}` splitMethod)
     : `\refvar{maxPrimsInNode}{}`(std::min(255, maxPrimsInNode)), `\refvar[BVHAccel::primitives]{primitives}{}`(p),
       `\refvar{splitMethod}{}`(splitMethod) {
    if (primitives.size() == 0)
        return;
    `\refcode{Build BVH from primitives}{}`
}
\end{lstlisting}
\begin{lstlisting}
`\initcode{BVHAccel Private Data}{=}\initnext{BVHAccelPrivateData}`
const int `\initvar{maxPrimsInNode}{}`;
const `\refvar{SplitMethod}{}` `\initvar{splitMethod}{}`;
std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> `\initvar[BVHAccel::primitives]{primitives}{}`;
\end{lstlisting}

\subsection{BVH构建}\label{sub:BVH构建}
这里的实现中构建BVH有三个阶段。
首先，计算关于每个图元的边界信息并保存到将于树构建期间使用的数组中。
接着，用选择的编码于\refvar{SplitMethod}{}的算法构建树。
结果是\keyindex{二叉树}{binary tree}{}每个内部节点
都有指针指向其孩子且每个叶子节点都有指向一个或多个图元的引用。
最后，该树转化为更紧实（且因此更高效）的无指针表示以供渲染时使用
（虽然在构建树期间直接计算无指针表示也可以，但用该方法实现更简单）。
\begin{lstlisting}
`\initcode{Build BVH from primitives}{=}`
`\refcode{Initialize primitiveInfo array for primitives}{}`
`\refcode{Build BVH tree for primitives using primitiveInfo}{}`
`\refcode{Compute representation of depth-first traversal of BVH tree}{}`
\end{lstlisting}

对于每个要存于BVH的图元，我们在结构体\refvar{BVHPrimitiveInfo}{}的一个实例中
存储其边界框的形心、完整边界框以及它在\refvar{primitives}{}数组中的索引。
\begin{lstlisting}
`\initcode{Initialize primitiveInfo array for primitives}{=}`
std::vector<`\refvar{BVHPrimitiveInfo}{}`> primitiveInfo(`\refvar[BVHAccel::primitives]{primitives}{}`.size());
for (size_t i = 0; i < `\refvar[BVHAccel::primitives]{primitives}{}`.size(); ++i)
    primitiveInfo[i] = { i, `\refvar[BVHAccel::primitives]{primitives}{}`[i]->`\refvar[Primitive::WorldBound]{WorldBound}{}`() };
\end{lstlisting}
\begin{lstlisting}
`\initcode{BVHAccel Local Declarations}{=}\initnext{BVHAccelLocalDeclarations}`
struct `\initvar{BVHPrimitiveInfo}{}` {
    `\refvar{BVHPrimitiveInfo}{}`(size_t primitiveNumber, const `\refvar{Bounds3f}{}` &bounds)
        : `\refvar{primitiveNumber}{}`(primitiveNumber), `\refvar[BVHPrimitiveInfo::bounds]{bounds}{}`(bounds),
          `\refvar{centroid}{}`(.5f * bounds.`\refvar{pMin}{}` + .5f * bounds.`\refvar{pMax}{}`) { }
    size_t `\initvar{primitiveNumber}{}`;
    `\refvar{Bounds3f}{}` `\initvar[BVHPrimitiveInfo::bounds]{bounds}{}`;
    `\refvar{Point3f}{}` `\initvar{centroid}{}`;
};
\end{lstlisting}

现在可以开始层次构建了。如果选择HLBVH构建算法，则调用\refvar{HLBVHBuild}{()}
构建树。其他三种构建算法都由\refvar{recursiveBuild}{()}负责。
初始调用这些函数时传递了所有要存于树中的图元。
它们返回一个指向树根的指针，用结构体\refvar{BVHBuildNode}{}表示。
树节点应该用提供的\refvar{MemoryArena}{}分配内存，
创建的总数应存于{\ttfamily *totalNodes}中。

树构建过程的一个重要副作用是通过参数{\ttfamily orderedPrims}返回指向图元的新指针数组；
该数组保存了有序的图元这样叶子节点的图元在数组中占有连续的范围。
在树构建后它与原始的\refvar[BVHAccel::primitives]{primitives}{}数组交换。
\begin{lstlisting}
`\initcode{Build BVH tree for primitives using primitiveInfo}{=}`
`\refvar{MemoryArena}{}` arena(1024 * 1024);
int totalNodes = 0;
std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> orderedPrims;
`\refvar{BVHBuildNode}{}` *root;
if (splitMethod == `\refvar{SplitMethod}{}`::`\refvar{HLBVH}{}`)
    root = `\refvar{HLBVHBuild}{}`(arena, primitiveInfo, &totalNodes, orderedPrims);
else
    root = `\refvar{recursiveBuild}{}`(arena, primitiveInfo, 0, `\refvar[BVHAccel::primitives]{primitives}{}`.size(),
                          &totalNodes, orderedPrims);
`\refvar[BVHAccel::primitives]{primitives}{}`.swap(orderedPrims);
\end{lstlisting}

每个\refvar{BVHBuildNode}{}表示一个BVH节点。
所有节点存储一个\refvar{Bounds3f}{}以表示该节点下所有孩子的边界。
每个内部节点在\refvar[BVHBuildNode::children]{children}{}中存有指向其两个孩子的指针。
内部节点也记录图元沿哪个坐标轴划分分给它们的两个孩子；
该信息用于提高遍历算法的性能。
叶子节点需要记录哪个或哪些图元保存在它们中；
数组\refvar{BVHAccel::primitives}{}中从偏移量\refvar{firstPrimOffset}{}起
直到但不包括{\ttfamily\refvar{firstPrimOffset}{}+\refvar{nPrimitives}{}}的元素是叶子中的元素
（因此需要记录图元数组，这样就可以利用该表示，
而不是例如在每个叶子节点中保存一个大小可变的图元索引数组）。
\begin{lstlisting}
`\refcode{BVHAccel Local Declarations}{+=}\lastnext{BVHAccelLocalDeclarations}`
struct `\initvar{BVHBuildNode}{}` {
    `\refcode{BVHBuildNode Public Methods}{}`
    `\refvar{Bounds3f}{}` `\initvar[BVHBuildNode::bounds]{bounds}{}`;
    `\refvar{BVHBuildNode}{}` *`\initvar[BVHBuildNode::children]{children}{}`[2];
    int `\initvar{splitAxis}{}`, `\initvar{firstPrimOffset}{}`, `\initvar{nPrimitives}{}`;
};
\end{lstlisting}

我们将通过其孩子指针是否有值{\ttfamily nullptr}来分别区分叶子和内部节点。
\begin{lstlisting}
`\initcode{BVHBuildNode Public Methods}{=}\initnext{BVHBuildNodePublicMethods}`
void `\initvar{InitLeaf}{}`(int first, int n, const `\refvar{Bounds3f}{}` &b) {
    `\refvar{firstPrimOffset}{}` = first;
    `\refvar{nPrimitives}{}` = n;
    `\refvar[BVHBuildNode::bounds]{bounds}{}` = b;
    `\refvar[BVHBuildNode::children]{children}{}`[0] = `\refvar[BVHBuildNode::children]{children}{}`[1] = nullptr;
}
\end{lstlisting}

方法\refvar{InitInterior}{()}要求已创建两个孩子节点，这样它们的指针才能传入。
该要求让计算内部节点的边界更加容易了，因为孩子的边界可以立刻获得。
\begin{lstlisting}
`\refcode{BVHBuildNode Public Methods}{+=}\lastcode{BVHBuildNodePublicMethods}`
void `\initvar{InitInterior}{}`(int axis, `\refvar{BVHBuildNode}{}` *c0, `\refvar{BVHBuildNode}{}` *c1) {
    `\refvar[BVHBuildNode::children]{children}{}`[0] = c0;
    `\refvar[BVHBuildNode::children]{children}{}`[1] = c1;
    `\refvar[BVHBuildNode::bounds]{bounds}{}` = `\refvar[Union2]{Union}{}`(c0->`\refvar[BVHBuildNode::bounds]{bounds}{}`, c1->`\refvar[BVHBuildNode::bounds]{bounds}{}`);
    `\refvar{splitAxis}{}` = axis;
    `\refvar{nPrimitives}{}` = 0;
}
\end{lstlisting}

除了用于分配节点和\refvar{BVHPrimitiveInfo}{}结构体数组的\refvar{MemoryArena}{}外，\linebreak
\refvar{recursiveBuild}{()}接收范围参数{\ttfamily[start,end)}。
它负责为从{\ttfamily primitiveInfo [start]}直到并包括{\ttfamily primitiveInfo[end-1]}的
范围表示的图元子集返回一个BVH。
如果该范围只含有单个图元，则递归触底并创建一个叶子节点。
否则，该方法用划分算法之一来划分数组该范围内的元素并相应地重新排列它们，
这样范围{\ttfamily[start,mid)}和{\ttfamily[mid,end)}表示分开的子集。
如果划分成功，则这两个图元集合又传入将会为当前节点的两个孩子返回节点指针的递归调用。

{\ttfamily totalNodes}跟踪已创建的BVH节点总数；
利用该数目使得之后可以分配数目恰好正确的更紧实的\refvar{LinearBVHNode}{}。
最终，数组{\ttfamily orderedPrims}用于保存图元引用就像图元存于树的叶子节点一样。
该数组初始化为空；当创建一个叶子节点时，\refvar{recursiveBuild}{()}把
与之重合的图元添加到数列末尾，让叶子节点可以只存储对该数组的偏移量以及
表示与之重合的图元集的图元数量。
回想当完成树构建时，用这里创建的有序图元数组代替\refvar{BVHAccel::primitives}{}。
\begin{lstlisting}
`\refcode{BVHAccel Method Definitions}{+=}\lastnext{BVHAccelMethodDefinitions}`
`\refvar{BVHBuildNode}{}` *`\refvar{BVHAccel}{}`::`\initvar{recursiveBuild}{}`(`\refvar{MemoryArena}{}` &arena,
        std::vector<`\refvar{BVHPrimitiveInfo}{}`> &primitiveInfo, int start,
        int end, int *totalNodes,
        std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> &orderedPrims) {
    `\refvar{BVHBuildNode}{}` *node = arena.`\refvar[MemoryArena:Alloc2]{Alloc}{}`<`\refvar{BVHBuildNode}{}`>();
    (*totalNodes)++;
    `\refcode{Compute bounds of all primitives in BVH node}{}`
    int nPrimitives = end - start;
    if (nPrimitives == 1) {
        `\refcode{Create leaf BVHBuildNode}{}`
    } else {
        `\refcode{Compute bound of primitive centroids, choose split dimension dim}{}`
        `\refcode{Partition primitives into two sets and build children}{}`
    }
    return node;
}
\end{lstlisting}
\begin{lstlisting}
`\initcode{Compute bounds of all primitives in BVH node}{=}`
`\refvar{Bounds3f}{}` bounds;
for (int i = start; i < end; ++i)
    bounds = `\refvar[Union2]{Union}{}`(bounds, primitiveInfo[i].`\refvar[BVHPrimitiveInfo::bounds]{bounds}{}`);
\end{lstlisting}

在叶子节点处，与该叶子重合的图元被添到{\ttfamily orderedPrims}数组末尾并初始化一个叶子节点对象。
\begin{lstlisting}
`\initcode{Create leaf BVHBuildNode}{=}`
int firstPrimOffset = orderedPrims.size();
for (int i = start; i < end; ++i) {
    int primNum = primitiveInfo[i].`\refvar{primitiveNumber}{}`;
    orderedPrims.push_back(`\refvar[BVHAccel::primitives]{primitives}{}`[primNum]);
}
node->`\refvar{InitLeaf}{}`(firstPrimOffset, nPrimitives, bounds);
return node;
\end{lstlisting}

对于内部节点，一组图元必须在两个子树之间划分。
给定$n$个图元，有$2^{n-1}-1$种\sidenote{译者注：原文误写为$2(n-1)-2$，已修正。}
可能的方法将它们划分到两个非空组。
实际中构建BVH时，一般考虑沿一个坐标轴划分，这意味着大约有$3n$个候选划分
（沿每个轴方向，每个图元可能放到第一分区或第二分区）。

这里我们就选择三个坐标轴的一个用来划分图元。
当为当前图元集合投影边界框形心时，我们选择有最大范围的轴
（另一种是尝试所有三个轴并选择给出最好结果的那个，但实际中本方法更好）。
该方法在许多场景下给出良好划分；\reffig{4.3}说明了该策略。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/BVHchoosesplitaxis.tex}
    \caption{选择沿哪个轴划分图元。\protect\refvar{BVHAccel}{}基于
        图元边界框形心在哪个轴有最大范围来选择划分图元所沿的轴。
        这里在二维中，它们沿$y$轴的范围最大（轴上的实心点），所以图元会在$y$上划分。}
    \label{fig:4.3}
\end{figure}

这里划分的一般目标是选择图元的一个划分使得
得到的两个图元集合的边界框没有太多重合——
如果有大量重合则在遍历树时它会更频繁地需要遍历两个子树，
比起本应可以更高效剪除一些图元它需要更多计算量。
待会儿在讨论表面积启发法时会更严谨地表述该求取高效图元划分的思想。
\begin{lstlisting}
`\initcode{Compute bound of primitive centroids, choose split dimension dim}{=}`
`\refvar{Bounds3f}{}` centroidBounds;
for (int i = start; i < end; ++i)
    centroidBounds = `\refvar[Union2]{Union}{}`(centroidBounds, primitiveInfo[i].`\refvar{centroid}{}`);
int dim = centroidBounds.`\refvar{MaximumExtent}{}`();
\end{lstlisting}

如果所有形心点都在同一位置（即形心边界为零体积），
则递归停止并用该图元创建一个叶子结点；
这里没有划分方法能对那种（非常）情况有效。
否则用选择的方法划分图元并传入两个对\refvar{recursiveBuild}{()}的递归调用。
\begin{lstlisting}
`\initcode{Partition primitives into two sets and build children}{=}`
int mid = (start + end) / 2;
if (centroidBounds.`\refvar{pMax}{}`[dim] == centroidBounds.`\refvar{pMin}{}`[dim]) {
    `\refcode{Create leaf BVHBuildNode}{}`
} else {
    `\refcode{Partition primitives based on splitMethod}{}`
    node->`\refvar{InitInterior}{}`(dim,
                       `\refvar{recursiveBuild}{}`(arena, primitiveInfo, start, mid,
                                      totalNodes, orderedPrims),
                       `\refvar{recursiveBuild}{}`(arena, primitiveInfo, mid, end,
                                      totalNodes, orderedPrims));
}
\end{lstlisting}

代码片\refcode{Partition primitives based on splitMethod}{}只是用
\refvar[splitMethod]{BVHAccel::splitMethod}{}
的值决定该用哪个图元划分方案。接下来的几页将介绍这三个方案。
\begin{lstlisting}
`\initcode{Partition primitives based on splitMethod}{=}`
switch (`\refvar{splitMethod}{}`) {
case `\refvar{SplitMethod}{}`::`\refvar{Middle}{}`: {
    `\refcode{Partition primitives through node's midpoint}{}`
}
case `\refvar{SplitMethod}{}`::`\refvar{EqualCounts}{}`: {
    `\refcode{Partition primitives into equally sized subsets}{}`
    break;
}
case `\refvar{SplitMethod}{}`::`\refvar{SAH}{}`:
default: {
    `\refcode{Partition primitives using approximate SAH}{}`
    break;
}
}
\end{lstlisting}

\refvar{Middle}{}是一个简单的\refvar{SplitMethod}{}，
它首先计算图元形心沿划分轴的中点。
该方法在代码片\refcode{Partition primitives through node's midpoint}{}中实现。
图元按其形心在中点之上还是之下分为两个集合。
该划分用C++标准库函数{\ttfamily std::partition()}很容易完成，
它接收数组中的一系列元素和比较函数，并对数组元素排序使得
对于判定函数而言所有返回{\ttfamily true}的元素都出现在返回{\ttfamily false}的范围之前
\footnote{在调用{\ttfamily std::partition()}时，
注意数组{\ttfamily primitiveInfo}索引的特殊表达式即{\ttfamily \&primitiveInfo[end-1]+1}。
这样写代码有些晦涩的理由。在C和C++程序语言中，
计算数组末尾后下一个元素的指针是合法的，
这样遍历数组元素能持续到当前指针等于末端点。
为此，我们这里想就写成表达式{\ttfamily \&primitiveInfo[end]}。
然而{\ttfamily primitiveInfo}分配为C++的{\ttfamily vector}；
一些{\ttfamily vector}实现在传给其{\ttfamily []}操作符
的偏移量是在数组末端之后时会报运行时错误。
因为我们不会尝试引用数组末端后下一个元素的值而只是想计算其地址，
所以该操作事实上是安全的。
因此我们最终用这里的表达式计算同一地址，并且也满足任何{\ttfamily vector}错误检查。}。
{\ttfamily std::partition()}返回指向第一个对于判定有{\ttfamily false}值的元素的指针，
它转化为对数组{\ttfamily primitiveInfo}的偏移量，这样我们就可以将其传入递归调用。
\reffig{4.4}说明了该方法，包括其有效和无效的情况。

如果图元都有巨大的重叠边界框，则该划分方法可能无法把图元分为两组。
这种情况下，执行往下进入{\ttfamily \refvar{SplitMethod}{}::\refvar{EqualCounts}{}}方法再试一次。
\begin{lstlisting}
`\initcode{Partition primitives through node's midpoint}{=}`
`\refvar{Float}{}` pmid = (centroidBounds.`\refvar{pMin}{}`[dim] + centroidBounds.`\refvar{pMax}{}`[dim]) / 2;
`\refvar{BVHPrimitiveInfo}{}` *midPtr =
    std::partition(&primitiveInfo[start], &primitiveInfo[end-1]+1,
        [dim, pmid](const `\refvar{BVHPrimitiveInfo}{}` &pi) {
            return pi.`\refvar{centroid}{}`[dim] < pmid;
        });
mid = midPtr - &primitiveInfo[0];
if (mid != start && mid != end)
    break;
\end{lstlisting}

当\refvar{splitMethod}{}是{\ttfamily\refvar{SplitMethod}{}::\refvar{EqualCounts}{}}时，
则运行代码片\refcode{Partition primitives into equally sized subsets}{}。
它把图元划分为两个数量相等的子集使得$n$个中前一半的$\displaystyle\frac{n}{2}$个
沿所选轴的形心坐标最小，另一半的则有最大形心坐标值。
尽管该方法有时能起效，但也有\reffig{4.4}(b)效果不好的情况。
\begin{figure}[htb]
    \centering\input{Pictures/chap04/Midpointgoodbadsplit.tex}
    \caption{一轴上基于形心中点划分图元。(a)对于一些图元分布，
        例如这里所示，沿所选轴（粗蓝线）基于形心中点的划分效果很好。
        (b)对于像这个的分布，中点是次优选项；所得两个边界框大量重叠。
        (c)若来自(b)的同一组图元换为用这里展示的线分开，所得边界框
        更小且根本不会重叠，使渲染时性能更好。}
    \label{fig:4.4}
\end{figure}

该方案也易于调用标准库的{\ttfamily std::nth\_element()}实现。
它接收起点、中点和终点指针以及一个比较函数。
它对数组排序使得中点指针处元素的位置是，如果数组完全排序，
则所有中点之前的元素都比中点元素小且所有后面的元素都比它大。
对于$n$个元素该排序可以在$O(n)$时间内完成，
比完全排序数组的$O(n\log{n})$更高效。
\begin{lstlisting}
`\initcode{Partition primitives into equally sized subsets}{}`
mid = (start + end) / 2;
std::nth_element(&primitiveInfo[start], &primitiveInfo[mid], 
                 &primitiveInfo[end-1]+1,
    [dim](const BVHPrimitiveInfo &a, const BVHPrimitiveInfo &b) { 
        return a.`\refvar{centroid}{}`[dim] < b.`\refvar{centroid}{}`[dim];
    });
\end{lstlisting}

\subsection{表面积启发法}\label{sub:表面积启发法}
上述两个图元划分方法对一些图元分布效果不错，
但实际中它们经常选择性能较差的划分，导致光线要访问树的更多节点，
因此带来渲染时不必要的低效光线-图元相交计算。
当下光线追踪大部分最好的构建加速结构算法都基于“\keyindex{表面积启发法}{surface area heuristic}{}”(SAH)，
它提供了全面的开销模型来回答问题，例如
“大量图元划分中哪个会为光线-图元相交测试带来更好的BVH？”，
或者“在空间划分方案里大量划分空间的可选位置中哪个会带来更好的加速结构？”

SAH模型估计执行光线相交测试的开销，包括穿行树的节点花的时间和
为特定的图元划分进行光线-图元相交测试花的时间。
然后构建加速结构的算法可以遵循最小化总开销的目标。
通常用贪婪算法独立地为正在构建的每个层次节点最小化开销。

SAH开销模型背后的思想很简单：构建自适应加速结构（图元划分或空间划分）的任意点处，
我们只用为当前区域和几何体创建一个叶子结点。
这种情况下，任何穿过该区域的光线都要对所有重合的图元测试，
且带来的开销为
\begin{align*}
    \sum\limits_{i=1}^{N}{t_{\mathrm{isect}}(i)}\, ,
\end{align*}
其中$N$是图元数量，$t_{\mathrm{isect}}(i)$是对第$i$个图元计算光线-物体相交的时间。

另一选项是划分空间。这种情况下，光线会带来开销
\begin{align}\label{eq:4.1}
    c(A,B)=t_{\mathrm{trav}}+p_A\sum\limits_{i=1}^{N_A}{t_\mathrm{isect}(a_i)}+p_B\sum\limits_{i=1}^{N_B}{t_{\mathrm{isect}}(b_i)}\, ,
\end{align}
其中$t_{\mathrm{trav}}$是穿行内部节点并确定光线穿过哪个子树所花的时间，分别地，
$p_A$和$p_B$是光线穿过每个子节点（假设二分划分）的概率，
$a_i$和$b_i$是两个子节点中图元的索引，
$N_A$和$N_B$是与两个子节点区域重合的图元数量。
怎样划分图元的选项会影响两个概率值以及划分出的两边的图元集合。

pbrt中，我们将作出简化假设即所有图元的$t_{\mathrm{trav}}(i)$都相同；
该假设可能和实际差不了多少，且它引入的任何误差看起来并不太影响加速器的性能。
另一种可能是向\refvar{Primitive}{}添加一个方法返回估计的相交测试所需的CPU周期数。

概率$p_A$和$p_B$可用来自几何概型的思想计算。
可以证明当凸体$A$包含于另一凸体$B$中，
穿过$B$的均匀分布的随机光线也穿过$A$的条件概率是它们表面积$s_A$与$s_B$的比：
\begin{align*}
    \displaystyle p(A|B)=\frac{s_A}{s_B}\, .
\end{align*}

因为我们对光线穿过节点的开销感兴趣，我们可以直接利用该结果。
因此，如果我们考虑细化一空间区域$A$使得有两个新子区域边界为$B$和$C$（\reffig{4.5}），
则穿过$A$的光线也会穿过两个子区域之一的概率很容易计算。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/Surfaceareasplit.tex}
    \caption{如果边界层次一个表面积为$s_A$的节点分为两个表面积为$s_B$和$s_C$的孩子，
        则穿过$A$的光线也穿过$B$和$C$的概率分别为$\displaystyle\frac{s_B}{s_A}$和$\displaystyle\frac{s_C}{s_A}$。}
    \label{fig:4.5}
\end{figure}

当\refvar{splitMethod}{}值为{\ttfamily\refvar{SplitMethod}{}::\refvar{SAH}{}}时，SAH用于构建BVH；
通过考虑大量候选划分来寻找沿所选轴给出最小SAH估计开销的图元划分
（这是默认\refvar{SplitMethod}{}，且它为渲染创建最高效的树）。
然而，一旦它细分少量图元，则实现切换为划分成等量的子集。
这时应用SAH所增加的计算量是不划算的。
\begin{lstlisting}
`\initcode{Partition primitives using approximate SAH}{=}`
if (nPrimitives <= 4) {
    `\refcode{Partition primitives into equally sized subsets}{}`
} else {
    `\refcode{Allocate BucketInfo for SAH partition buckets}{}`
    `\refcode{Initialize BucketInfo for SAH partition buckets}{}`
    `\refcode{Compute costs for splitting after each bucket}{}`
    `\refcode{Find bucket to split at that minimizes SAH metric}{}`
    `\refcode{Either create leaf or split primitives at selected SAH bucket}{}`
}
\end{lstlisting}

比起穷举沿该轴所有$2n$个可能的划分，这里的实现是
将沿该轴的范围分为少量相等的较大范围，并为每个计算SAH以选择最好的。
然后它只考虑在该范围边界内的划分。
该方法比考虑所有划分更高效且通常仍产出几乎一样高效的划分。
\reffig{4.6}说明了该思想。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/BVHsplitbucketing.tex}
    \caption{用表面积启发法为BVH选择划分平面。图元边界形心的投影范围被投影在选定的划分轴上。
        每个图元都基于其边界形心被放在沿轴的一个桶中。
        然后实现会估计沿每个桶的边界（粗蓝线）的平面划分图元的开销；
        谁的表面积启发法开销最小就选谁。}
    \label{fig:4.6}
\end{figure}
\begin{lstlisting}
`\initcode{Allocate BucketInfo for SAH partition buckets}{=}`
constexpr int nBuckets = 12;
struct `\initvar{BucketInfo}{}` {
    int `\initvar[BucketInfo::count]{count}{}` = 0;
    `\refvar{Bounds3f}{}` `\initvar[BucketInfo::bounds]{bounds}{}`;
};
`\refvar{BucketInfo}{}` buckets[nBuckets];
\end{lstlisting}

对于该范围内的每个图元，我们确定包含其形心的桶\protect\sidenote{译者注：原文bucket。}并更新桶的边界以包含图元的边界。
\begin{lstlisting}
`\initcode{Initialize BucketInfo for SAH partition buckets}{=}`
for (int i = start; i < end; ++i) {
    int b = nBuckets * 
        centroidBounds.`\refvar{Offset}{}`(primitiveInfo[i].`\refvar{centroid}{}`)[dim];
    if (b == nBuckets) b = nBuckets - 1;
    buckets[b].`\refvar[BucketInfo::count]{count}{}`++;
    buckets[b].`\refvar[BucketInfo::bounds]{bounds}{}` = `\refvar[Union2]{Union}{}`(buckets[b].`\refvar[BucketInfo::bounds]{bounds}{}`, primitiveInfo[i].`\refvar[BVHPrimitiveInfo::bounds]{bounds}{}`);
}
\end{lstlisting}

对于每个桶，我们现在都有图元数量以及全部相应边界框的边界。
我们想用SAH估计在每个桶边界处作划分的开销。
下面的代码片遍历所有桶并初始化数组{\ttfamily cost[i]}来
保存估计的在第{\ttfamily i}个桶后划分的SAH开销
（不考虑在最后一个桶之后划分，因为根据定义它并不划分图元）。

我们任意设置估计的相交开销为1，然后设置估计的遍历开销
为$\displaystyle\frac{1}{8}$（两者之一总是可以设为1，
因为是估计的遍历和相交开销的相对量级而不是绝对量级决定其影响）。
尽管遍历节点即光线-边界框相交的绝对计算量仅稍低于光线与形状相交所需的计算量，
但pbrt中光线-图元相交测试经过了两次虚函数调用，增加了大量开销，
所以这里我们估计其开销大于光线-框相交的八倍。

基于对桶前向和后向扫描而增量式地计算、存储和计数边界的线性时间实现是可能的，
但这里的计算关于桶的数量有$O(n^2)$复杂度。
更加高度优化解决该低效问题的渲染器是值得的，
但这里对于小的$n$，性能影响通常是可接受的。
\begin{lstlisting}
`\initcode{Compute costs for splitting after each bucket}{=}`
`\refvar{Float}{}` cost[nBuckets - 1];
for (int i = 0; i < nBuckets - 1; ++i) {
    `\refvar{Bounds3f}{}` b0, b1;
    int count0 = 0, count1 = 0;
    for (int j = 0; j <= i; ++j) {
        b0 = `\refvar[Union2]{Union}{}`(b0, buckets[j].`\refvar[BucketInfo::bounds]{bounds}{}`);
        count0 += buckets[j].`\refvar[BucketInfo::count]{count}{}`;
    }
    for (int j = i+1; j < nBuckets; ++j) {
        b1 = `\refvar[Union2]{Union}{}`(b1, buckets[j].`\refvar[BucketInfo::bounds]{bounds}{}`);
        count1 += buckets[j].`\refvar[BucketInfo::count]{count}{}`;
    }
    cost[i] = .125f + (count0 * b0.`\refvar{SurfaceArea}{}`() +
                       count1 * b1.`\refvar{SurfaceArea}{}`()) / bounds.`\refvar{SurfaceArea}{}`();
}
\end{lstlisting}

有了所有开销，对数组{\ttfamily cost}的线性扫描找到最小开销的划分。
\begin{lstlisting}
`\initcode{Find bucket to split at that minimizes SAH metric}{=}`
`\refvar{Float}{}` minCost = cost[0];
int minCostSplitBucket = 0;
for (int i = 1; i < nBuckets - 1; ++i) {
    if (cost[i] < minCost) {
        minCost = cost[i];
        minCostSplitBucket = i;
    }
}
\end{lstlisting}

如果为划分选的桶边界有比用存在的图元构建节点更低的估计开销，
或者出现一个节点的图元超过了允许的最大数量，
则用函数{\ttfamily std::partition()}来完成
在数组{\ttfamily primitiveInfo}中记录节点的工作。
回想之前它的用法即该函数确保数组的所有对于给定判定函数返回{\ttfamily true}的元素
都出现在返回{\ttfamily false}的之前，
并且它返回指向第一个判定函数返回{\ttfamily false}的元素的指针。
因为我们之前任意设置估计的相交开销为1，
所以只是创建叶子结点的估计开销等于图元的数量{\ttfamily nPrimitives}。
\begin{lstlisting}
`\initcode{Either create leaf or split primitives at selected SAH bucket}{=}`
`\refvar{Float}{}` leafCost = nPrimitives;
if (nPrimitives > maxPrimsInNode || minCost < leafCost) {
    `\refvar{BVHPrimitiveInfo}{}` *pmid = std::partition(&primitiveInfo[start],
        &primitiveInfo[end-1]+1, 
        [=](const `\refvar{BVHPrimitiveInfo}{}` &pi) {
            int b = nBuckets * centroidBounds.`\refvar{Offset}{}`(pi.centroid)[dim];
            if (b == nBuckets) b = nBuckets - 1;
            return b <= minCostSplitBucket;
        });
    mid = pmid - &primitiveInfo[0];
} else {
    `\refcode{Create leaf BVHBuildNode}{}`
}
\end{lstlisting}

\subsection{线性包围盒层次}\label{sub:线性包围盒层次}
尽管用表面积启发法构建包围盒层次给出了很好的结果，
但该方法有两个缺点：第一，采用了场景图元上的许多通道
来在树的所有层次上计算SAH开销\sidenote{译者注：本句翻译不确定。}。
第二，自顶向下的BVH构建难以很好地并行化：
最明显的并行化方法——执行独立子树的并行化构建——
在直到该树顶部几层构建好前都受困于有限的独立任务，
这反过来又抑制了并行的可扩展性
（第二个问题在GPU上尤为突出，如果大规模并行化不可用则性能会很差）。

开发\keyindex{线性包围盒层次}{linear bounding volume hierarchies}{}(LBVH)来解决这些问题。
通过LBVH，以图元上少量的轻量级通道来构建树\sidenote{译者注：本句翻译不确定。}；
树的构建时间与图元数量呈线性关系。
而且算法快速地把图元划分为可以独立处理的\keyindex{群集}{cluster}{}。
该过程很容易并行化且很适合GPU实现。

LBVH背后的关键思想是把BVH构建变为排序问题。
因为没有排序多维数据的单一顺序函数，所以LBVH是基于\keyindex{莫顿码}{Morton code}{}的，
它将$n$维中的邻近点映射为1D直线上的邻近点，使之有明显的排序函数。
在图元排序后，空间上相邻的图元群集在排序数组的连续段内。

莫顿码基于简单的变换：给定$n$维整数坐标值，
其莫顿码表示由交错二进制坐标数位求得。
例如，考虑一个2D坐标$(x,y)$，其中$x$和$y$的数位表示为$x_i$和$y_i$。
相应的莫顿码值为
\begin{align*}
    \cdots y_3x_3y_2x_2y_1x_1y_0x_0\, .
\end{align*}

\reffig{4.7}展示了2D点按莫顿顺序的图示——
注意沿递归的“z”形路径访问它们
（因此莫顿路径有时也称为“z序”）。
我们可以看到2D中坐标相近的点通常在莫顿曲线上也是相近的
\footnote{许多GPU用莫顿布局在内存中存储纹理贴图。
这样做的一个优点是当在四个纹素值之间执行双线性插值时，
比起纹理按扫描线顺序排布，这些值更有极大可能在内存中相邻。
反过来，这有利于纹理缓存性能。}。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/MortonBasic.tex}
    \caption{沿莫顿曲线访问点的顺序。沿$x$和$y$轴的坐标值用二进制表示。
    如果我们按其莫顿索引的顺序连接整数坐标点，我们可以看见莫顿曲线沿分层级的“z”形路径访问这些点。}
    \label{fig:4.7}
\end{figure}

莫顿编码值也编码了关于点所表示的位置的有用信息。