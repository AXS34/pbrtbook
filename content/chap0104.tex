\section{pbrt的并行化}\label{sec:pbrt的并行化}

现在几乎不可能买到只有一个处理核的新笔记本或台式计算机了。
（甚至对许多手机而言也是如此。）
今天和未来的计算机系统在CPU和
高并行吞吐量处理器如GPU上都会
有越来越多的处理核心。
同时，核心的计算能力却提升缓慢；
因此随着时间推移，
明显的性能提升只会出现在可以\keyindex{并行}{parallel}{}运行的程序上，
其许多独立的执行线程同时在多核上进行计算。

编写并行程序比写\keyindex{串行}{serial}{}程序复杂得多。
当两组程序员认为该独立同时执行的计算意外相互影响时，
程序可能会崩溃或产生意外结果。
然而，再次运行程序时这种bug可能不会再出现，
因为那些特定计算下次再运行时可能没有同时执行。
幸运的是，有越来越多有用的工具帮助开发者找出这类问题。

并行程序为了良好扩展到多核上，
需要能提供大量独立运算：
任何依赖于先前计算结果的运算都不能
与被依赖者同时执行。
幸运的是，大多数基于光线追踪的渲染算法具有丰富的\keyindex{并行性}{parallelism}{}；
对于\refvar{SamplerIntegrator}{}，
每个图像样本之间都相互独立，
高质量图像可能会用几百万个样本。

并行光线追踪最大的挑战之一是非并行计算阶段的影响。
例如在构建场景时，高效地并行化许多加速结构的构造
并不像并行化渲染那样简单。
但这看起来是个小问题，因为\keyindex{阿姆达尔定律}{Amdahl's law}{}描述了
同时具有串行和并行阶段的工作负载的加速问题这一挑战。
设有$n$个核执行计算，全部工作负载中占比$s$的部分是固有串行的，
则可能的最大加速比是
\begin{align*}
    \frac{1}{\displaystyle s+\frac{1}{n}(1-s)}\, .
\end{align*}
因此，即使有无限多数量的核，加速比最多为$\displaystyle\frac{1}{s}$。
例如如果解析场景文件和建立加速结构的串行阶段
所花的时间占了看似无妨的5\%，
则不论并行阶段执行得有多快，
可能的加速比最多为1/0.05=20倍。