\section{使用和理解代码}\label{sec:使用和理解代码}

我们用C++写成pbrt但限制使用艰深的语言特性，让非C++专家也易读。
紧贴核心语言特性还有利于系统的可移植性。
特别地，我们避免了多重继承、运行时异常处理
以及对C++11和C++14特性的过度使用。
此外我们只用了C++扩展标准库的一小部分。

\subsection{指针还是引用？}\label{sub:指针还是引用？}
C++提供了两种不同的机制来向函数或方法传递
数据结构的地址：\keyindex{指针}{pointer}{}和\keyindex{引用}{reference}{}。
如果函数参数不会当做输出变量，
则用任意一种都可以节约在堆栈上传递整个结构的开销。
按惯例，pbrt在参数会被函数或方法完全改变时使用指针，
在其一些内部状态会被改变但不会被完全重新初始化时使用引用，
在根本不会被改变时使用{\ttfamily const}引用。
这条规则的一个例外是当我们想传递{\ttfamily nullptr}来
表示该参数不可用或不该用时我们总是使用指针。

\subsection{抽象与效率}\label{sub:抽象与效率}
设计软件系统接口的一大压力是在抽象与效率间作出合理的平衡。
例如，许多程序员严谨地让类的所有数据都是{\ttfamily private}的
并提供方法来获取或修改数据项的值。
对于简单的类（例如\refvar{Vector3f}{}），我们认为
这种方案不必要地隐藏了实现的基本属性——该类持有的三个浮点坐标——
我们可以合理认为它们一直不变。
当然，缺乏信息隐藏并暴露所有类内部全部细节的做法会导致代码维护的噩梦。
但是我们认为在整个系统中审慎地暴露基本设计决策是没错的。
例如事实是，由一个点、一个向量、赋予其范围、时间的值以及递归深度
表示的\refvar{Ray}{}就不用隐藏在抽象层之后。
当这些细节暴露时别处的代码会更简短易懂。

当编写软件系统并做出此类时平衡时要时刻想到最终系统的预期大小。
定义了全部基本接口、抽象和策略决策的pbrt核心
（除了特定形状、光源等的实现外）代码不超过20,000行。
向系统添加额外功能一般只需增加不同抽象基类实现的代码量。
pbrt永远不会增长到百万行代码；
用于系统中的信息隐藏量可以且应该反映出这一事实。
设计接口来让系统适应那种程度的复杂度只会
浪费程序员的时间（还可能降低运行时效率）。

\subsection{代码优化}\label{sub:代码优化}
通过使用优选的算法而非局部的微小优化，我们尽量让pbrt足够高效。