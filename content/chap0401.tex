\section{图元接口与几何图元}\label{sec:图元接口与几何图元}

抽象基类\refvar{Primitive}{}是pbrt的几何处理与着色子系统之间的桥梁。
\begin{lstlisting}
`\initcode{Primitive Declarations}{=}`
class `\initvar{Primitive}{}` {
public:
    `\refcode{Primitive Interface}{}`
};
\end{lstlisting}

\refvar{Primitive}{}接口中有许多几何例程，它们全都与\refvar{Shape}{}相应的方法类似。
首先，方法\refvar{Primitive::WorldBound}{()}返回世界空间中装入图元几何体的框。
这样的框有许多用处；最重要之一是把\refvar{Primitive}{}放入加速数据结构。
\begin{lstlisting}
`\initcode{Primitive Interface}{=}\initnext{PrimitiveInterface}`
virtual `\refvar{Bounds3f}{}` `\initvar[Primitive::WorldBound]{WorldBound}{()}` const = 0;
\end{lstlisting}

接下来两个方法提供了光线相交测试。两个基类的差别之一是\linebreak
\refvar{Shape::Intersect}{()}在一个\refvar{Float}{*}输出变量中
返回沿射线到相交处的参数距离，而
\refvar{Primitive::Intersect}{()}则负责在找到相交处时用该值更新\refvar[tMax]{Ray::tMax}{}。
\begin{lstlisting}
`\refcode{Primitive Interface}{+=}\lastnext{PrimitiveInterface}`
virtual bool `\initvar[Primitive::Intersect]{Intersect}{}`(const `\refvar{Ray}{}` &r, `\refvar{SurfaceInteraction}{}` *) const = 0;
virtual bool `\initvar[Primitive::IntersectP]{IntersectP}{}`(const `\refvar{Ray}{}` &r) const = 0;
\end{lstlisting}

找到相交后，\refvar{Primitive}{}的方法\refvar[Primitive::Intersect]{Intersect}{()}也负责
初始化额外的\linebreak\refvar{SurfaceInteraction}{}成员变量，
包括指向射线命中的\refvar{Primitive}{}的指针。
\begin{lstlisting}
`\refcode{SurfaceInteraction Public Data}{+=}\lastnext{SurfaceInteractionPublicData}`
const `\refvar{Primitive}{}` *`\initvar{primitive}{}` = nullptr;
\end{lstlisting}

\refvar{Primitive}{}对象有一些方法也与非几何性质有关。
首先，如果该图元本身是光源，
则\refvar[GetAreaLight]{Primitive::GetAreaLight}{()}返回
一个指向描述图元发射分布的\refvar{AreaLight}{}的指针。
如果该图元不发光，则该方法应返回{\ttfamily nullptr}。
\begin{lstlisting}
`\refcode{Primitive Interface}{+=}\lastnext{PrimitiveInterface}`
virtual const `\refvar{AreaLight}{}` *`\initvar{GetAreaLight}{}`() const = 0;
\end{lstlisting}

\refvar{GetMaterial}{()}返回指向赋给该图元的材质实例的指针。
如果返回{\ttfamily nullptr}，则应该忽略与该图元的光线相交；
该图元只用于描述介质的一块空间。
通过比较其\refvar{Material}{}指针，该方法也用于检查两条光线是否相交于同一个物体。
\begin{lstlisting}
`\refcode{Primitive Interface}{+=}\lastnext{PrimitiveInterface}`
virtual const `\refvar{Material}{}` *`\initvar{GetMaterial}{}`() const = 0;
\end{lstlisting}

第三个与材质有关的方法\refvar[Primitive::ComputeScatteringFunctions]{ComputeScatteringFunctions}{()}初始化
曲面上交点处材质光散射性质的表示。
\refvar{BSDF}{}对象（\refsec{BSDF}介绍）描述了
交点处的局部光散射性质。
如果可用，该方法还初始化一个\refvar{BSSRDF}{}描述
图元内部的次表面散射——光照进入表面的点离退出的点很远。
尽管次表面光传输对诸如金属、布料或塑料的物体外观影响很小，
但它在生物材料如皮肤、粘稠液体如牛奶等的光散射机制中占主体。
\refvar{BSSRDF}{}由\refchap{光传输II：体积渲染}讨论的
扩展的光线追踪算法支持。

除了\refvar{MemoryArena}{}为\refvar{BSDF}{}和/或\refvar{BSSRDF}{}分配内存外，该方法还接收枚举量\linebreak
\refvar{TransportMode}{}表示找到该交点的光路是从相机开始还是从光源开始的；
正如\refsec{路径-空间测量方程}讨论的，
这些细节对怎样求取材质模型的某些部分给出了重要假设。
参数{\ttfamily allowMultipleLobes}控制着怎样表示一些类型的BRDF的细节；
它将于\refsec{材质接口与实现}讨论。
\refsub{BSDF内存管理}更详细地讨论\refvar{MemoryArena}{}用于\refvar{BSDF}{}内存分配。
\begin{lstlisting}
`\refcode{Primitive Interface}{+=}\lastcode{PrimitiveInterface}`
virtual void `\initvar[Primitive::ComputeScatteringFunctions]{ComputeScatteringFunctions}{}`(`\refvar{SurfaceInteraction}{}` *isect,
    `\refvar{MemoryArena}{}` &arena, `\refvar{TransportMode}{}` mode,
    bool allowMultipleLobes) const = 0;
\end{lstlisting}

该点的\refvar{BSDF}{}和\refvar{BSSRDF}{}指针
存于传入\refvar[Primitive::ComputeScatteringFunctions]{ComputeScatteringFunctions}{()}的\linebreak
\refvar{SurfaceInteraction}{}中。
\begin{lstlisting}
`\refcode{SurfaceInteraction Public Data}{+=}\lastnext{SurfaceInteractionPublicData}`
`\refvar{BSDF}{}` *`\initvar{bsdf}{}` = nullptr;
`\refvar{BSSRDF}{}` *`\initvar{bssrdf}{}` = nullptr;
\end{lstlisting}

\subsection{几何图元}\label{sub:几何图元}
类\refvar{GeometricPrimitive}{}表示场景中的单个形状（例如一个球体）。
用户提供的场景描述中的每个形状都被分配一个\refvar{GeometricPrimitive}{}。该类在文件
\href{https://github.com/mmp/pbrt-v3/tree/master/src/core/primitive.h}{\ttfamily core/primitive.h}和
\href{https://github.com/mmp/pbrt-v3/tree/master/src/core/primitive.cpp}{\ttfamily primitive.cpp}中实现。
\begin{lstlisting}
`\initcode{GeometricPrimitive Declarations}{=}`
class `\initvar{GeometricPrimitive}{}` : public `\refvar{Primitive}{}` {
public:
    `\refcode{GeometricPrimitive Public Methods}{}`
private:
    `\refcode{GeometricPrimitive Private Data}{}`
};
\end{lstlisting}

每个\refvar{GeometricPrimitive}{}持有
对\refvar{Shape}{}及其\refvar{Material}{}的引用。
此外，因为pbrt中的图元可能是面光源，
它存储一个指向描述其发射特性的\refvar{AreaLight}{}对象的指针
（如果该图元不发光则该指针设为{\ttfamily nullptr}）。
最后，\refvar{MediumInterface}{}
属性将关于图元内外部介质的信息编码。
\begin{lstlisting}
`\initcode{GeometricPrimitive Private Data}{=}`
std::shared_ptr<`\refvar{Shape}{}`> `\initvar[GeometricPrimitive::shape]{shape}{}`;
std::shared_ptr<`\refvar{Material}{}`> `\initvar[GeometricPrimitive::material]{material}{}`;
std::shared_ptr<`\refvar{AreaLight}{}`> `\initvar[GeometricPrimitive::areaLight]{areaLight}{}`;
`\refvar{MediumInterface}{}` `\initvar[GeometricPrimitive::mediumInterface]{mediumInterface}{}`;
\end{lstlisting}

\refvar{GeometricPrimitive}{}构造函数只从传入参数中初始化这些变量，很简单。
\begin{lstlisting}
`\initcode{GeometricPrimitive Public Methods}{=}`
virtual `\refvar{Bounds3f}{}` `\initvar[GeometricPrimitive::WorldBound]{WorldBound}{}`() const;
virtual bool `\refvar[GeometricPrimitive::Intersect]{Intersect}{}`(const `\refvar{Ray}{}` &r, `\refvar{SurfaceInteraction}{}` *isect) const;
virtual bool `\initvar[GeometricPrimitive::IntersectP]{IntersectP}{}`(const `\refvar{Ray}{}` &r) const;
`\refvar{GeometricPrimitive}{}`(const std::shared_ptr<`\refvar{Shape}{}`> &shape,
        const std::shared_ptr<`\refvar{Material}{}`> &material,
        const std::shared_ptr<`\refvar{AreaLight}{}`> &areaLight,
        const `\refvar{MediumInterface}{}` &mediumInterface)
    : `\refvar[GeometricPrimitive::shape]{shape}{}`(shape), `\refvar[GeometricPrimitive::material]{material}{}`(material), `\refvar[GeometricPrimitive::areaLight]{areaLight}{}`(areaLight),
    `\refvar[GeometricPrimitive::mediumInterface]{mediumInterface}{}`(mediumInterface) {
}
const `\refvar{AreaLight}{}` *`\initvar{GetAreaLight}{}`() const;
const `\refvar{Material}{}` *`\refvar{GetMaterial}{}`() const;
void `\refvar[GeometricPrimitive::ComputeScatteringFunctions]{ComputeScatteringFunctions}{}`(`\refvar{SurfaceInteraction}{}` *isect, `\refvar{MemoryArena}{}` &arena,
    `\refvar{TransportMode}{}` mode, bool allowMultipleLobes) const;
\end{lstlisting}

\refvar{Primitive}{}接口大多数与几何处理相关的方法
都简单地由\refvar{Shape}{}相应的方法得到。
例如，\refvar{GeometricPrimitive::Intersect}{()}调用
其所附的\refvar{Shape}{}的方法\refvar{Shape::Intersect}{()}
来进行实际的相交测试，如果有的话则初始化一个\refvar{SurfaceInteraction}{}来描述相交处。
它也用返回的参数化命中距离来更新成员\refvar[tMax]{Ray::tMax}{}。
在\refvar[tMax]{Ray::tMax}{}中存储到最近命中处距离的优点是更易
避免对任何沿射线比已找到的相交处还远的图元执行相交测试。
\begin{lstlisting}
`\initcode{GeometricPrimitive Method Definitions}{=}\initnext{GeometricPrimitiveMethodDefinitions}`
bool `\initvar{GeometricPrimitive::Intersect}{}`(const `\refvar{Ray}{}` &r,
        `\refvar{SurfaceInteraction}{}` *isect) const {
    `\refvar{Float}{}` tHit;
    if (!`\refvar[GeometricPrimitive::shape]{shape}{}`->`\refvar[Shape::Intersect]{Intersect}{}`(r, &tHit, isect))
        return false;
    r.`\refvar{tMax}{}` = tHit;
    isect->`\refvar{primitive}{}` = this;
    `\refcode{Initialize SurfaceInteraction::mediumInterface after Shape intersection}{}`
    return true;
}
\end{lstlisting}

我们这里不再介绍\refvar{GeometricPrimitive}{}的方法
\refvar[GeometricPrimitive::WorldBound]{WorldBound}{()}或\linebreak
\refvar[GeometricPrimitive::IntersectP]{IntersectP}{()}的实现；
它们只是以相同方式把这些请求传给\refvar{Shape}{}。同样，\linebreak
\refvar{GetAreaLight}{()}只是返回成员\refvar{GeometricPrimitive::areaLight}{}。

最后，方法\refvar[GeometricPrimitive::ComputeScatteringFunctions]{ComputeScatteringFunctions}{()}只是
把请求传给\refvar{Material}{}。
\begin{lstlisting}
`\refcode{GeometricPrimitive Method Definitions}{+=}\lastcode{GeometricPrimitiveMethodDefinitions}`
void `\initvar{GeometricPrimitive::ComputeScatteringFunctions}{}`(
        `\refvar{SurfaceInteraction}{}` *isect, `\refvar{MemoryArena}{}` &arena, `\refvar{TransportMode}{}` mode,
        bool allowMultipleLobes) const {
    if (`\refvar[GeometricPrimitive::material]{material}{}`)
        `\refvar[GeometricPrimitive::material]{material}{}`->`\refvar[Material::ComputeScatteringFunctions]{ComputeScatteringFunctions}{}`(isect, arena, mode,
            allowMultipleLobes);
}
\end{lstlisting}

\subsection{TransformedPrimitive：物体实例化与动画基元}\label{sub:TransformedPrimitive：物体实例化与动画基元}
