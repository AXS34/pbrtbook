\section{扩展阅读}\label{sec:扩展阅读04}
引入光线追踪算法之后，涌现了大量尝试寻找高效方法对其加速的研究，
主要是通过开发改进的光线追踪加速结构。
《\citetitle{10.5555/94788}》\citep{10.5555/94788}中Arvo和Kirk的章节
总结了1989年最新进展并为区分不同光线相交加速方法提供了优秀的分类方案。

Kirk和Arvo \parencite*{Kirk88theray}引入了\keyindex{元层次}{meta-hierarchies}{}的统一原则。
它们证明了通过让实现的加速数据结构与场景图元遵照相同的接口，
很容易混合与匹配不同的相交加速框架。
pbrt遵循这一模型，因为\refvar{Aggregate}{}继承自基类\refvar{Primitive}{}。

\subsection{网格}\label{sub:网格}
Fujimoto、Tanaka和Iwata\parencite*{4056861}引入了均匀网格，
即把场景边界分解为等长网格的空间细分方法。
Amanatides和Woo \parencite*{10.2312:egtp.19871000}
以及Cleary和Wyvill \parencite*{Cleary1988}描述了更高效的网格遍历方法。
Snyder和Barr \parencite*{10.1145/37401.37417}描述了
对该方法的大量改进并证明了网格对于渲染极其复杂场景的用处。
Jevans和Wyvill \parencite*{Jevans1989:23}引入了层次化网格，
即含有许多图元的网格自我细化为小格。
Cazals、Drettakis和Puech \parencite*{cazals1995filtering}以及
Klimaszewski和Sederberg \parencite*{576857}为层次化网格开发了更复杂的技术。

Ize等\parencite*{4061545}为网格的并行创建开发了高效算法。
他们的有趣发现之一是随着所用处理核数量的增长，
网格创建性能很快被有效内存带宽所限制。

选择最优网格分辨率对于从网格中获得优异性能很重要。
Ize等\parencite*{4342587}有该话题的优秀论文，
为完全自动化选择分辨率以及在使用层次化网格时决定何时细化为子网格提供了坚实基础。
他们用大量简化假设推导出理论结果，然后证明了这些结果渲染真实世界场景的适用性。
他们的论文也包括对该领域前人工作很好的筛选引用。

Lagae和Dutré \parencite*{lagae2008compact}基于
哈希法\sidenote{译者注：即hashing，也称散列法。}为均匀网格
描述了一种新颖的表示，它具有的优良性质是不仅每个图元
拥有对网格的单个索引，而且每个网格也只有单个图元索引。
他们证明了该表示有很低的内存使用量且仍然非常高效。

Hunt和Mark \parencite*{4634613}证明了在透视空间中构建网格，
即投影中心是相机或光源时，能让追踪相机或光源发出的光线高效得多。
尽管该方法需要多种加速结构，但从为不同种类光线专门设计的多种结构中获得的性能提升可以很高。
他们的方法也因在某种意义上是栅格化和光线追踪的中间地带而令人瞩目。

\subsection{包围盒层次}\label{sub:包围盒层次}
\citet{10.1145/360349.360354}首先建议为标准可见曲面确定算法使用包围盒来剔除物体集。
在此基础上，Rubin和Whitted \parencite*{10.1145/800250.807479}首先为快速光线追踪
的场景表示开发了层次化数据结构，尽管他们的方法依赖于用户去定义层次。
Kay和Kajiya \parencite*{10.1145/15922.15916}基于用厚板集定界物体实现了最早之一的实用物体细分方法。
Goldsmith和Salmon \parencite*{4057175}描述了自动计算包围盒层次的首个算法。
尽管他们的算法是基于依据盒的表面积来估计光线与包围盒相交的概率，
但它比现代SAH BVH算法低效得多。

本章的\refvar{BVHAccel}{}实现基于\citet{4342588}以及Günther等\parencite*{4342598}描述的构建算法。
边界框测试则是Williams等\parencite*{10.1145/1198555.1198748}引入的。
Eisemann等\parencite*{10.1080/2151237X.2007.10129248}开发了甚至更高效的边界框测试，
当同一光线对许多边界框做相交测试时它进行额外的预计算以换取更高的性能；
我们把实现他们的方法留作习题。

pbrt中用的BVH遍历算法由多位研究者同时开发出来；
见Boulos和Haines \parencite*{bouloshaines2006}的批注了解更多细节和背景。
树遍历的另一选项是Kay和Kajiya \parencite*{10.1145/15922.15916}；
他们维护一个按光线距离排序的节点堆。
在单片存储\sidenote{译者注：原文on-chip memory。}数量相对有限的GPU上，
为每条光线维护一个将要访问的节点的栈可能会有极其高的内存开销。
Foley和Sugerman \parencite*{10.1145/1071866.1071869}引入了
“无栈”\sidenote{译者注：原文stackless。}kd树遍历算法，
它周期性地从树根开始回溯和搜索以找到下一个要访问的节点而不是显式保存所有要访问的节点。
\citet{10.5555/1921479.1921496}对该方法做了大量改进，
减少了从树根重新遍历的频率并将该方法应用于BVH。

许多研究者已经为构建BVH后提升其质量开发了许多技术。
Yoon等\parencite*{10.2312:EGWR:EGSR07:073-084}和\citet{4634624}提出了
对BVH做局部调整的算法，Kopta等\parencite*{10.1145/2159616.2159649}在
一个动画的多个坐标系上复用BVH，通过更新包围运动物体的部分来保持其质量。
也见Bittner等\parencite*{BittnerFast2013}、Karras和Aila \parencite*{10.1145/2492045.2492055}
以及Bittner等\parencite*{BITTNER2015135}了解该领域的最新工作。

当前大多数构建BVH方法都基于自顶向下的树构建，
首先创建树节点然后将图元划分到孩子中并继续递归。
Walter等\parencite*{4634626}证明了另一个方法，
他说明自底向上的构建即首先创建叶子然后聚为父亲节点是可行选项。
Gu等\parencite*{10.1145/2492045.2492054}开发了该方法高效得多的实现并
证明了其对并行实现的适应性。

BVH的一个缺点是即便少量与边界框重合的相对较大的图元也会极大降低BVH的效率：
仅仅因为下沉到叶子的几何体的重合边界框\sidenote{译者注：此句翻译不确定。}，
许多树节点就会重合。Ernst和Greiner \parencite*{4342593}提出
“分割剪裁”\sidenote{译者注：原文split clipping。}的办法；
提出了树中每个图元只出现一次的约束，
并且巨大输入图元的边界框被细分为更紧致的子框集再用于树的构建。
Dammertz和Keller \parencite*{4634636}观察到有问题的图元是
那些相对于其表面积在其边界框内有大量空白空间的，
所以它们细分了最异常的三角形并报告有巨大性能提升。
Stich等\parencite*{10.1145/1572769.1572771}开发了
在BVH构建期间划分图元的方法，使得当发现SAH开销下降时可以只划分图元。
也见Popov等\parencite*{10.1145/1572769.1572772}理论上
优化BVH划分算法及其与之前方法的关系，
以及Karras和Aila \parencite*{10.1145/2492045.2492055}改进
决定何时分割三角形的准则。
Woop等\parencite*{10.5555/2980009.2980014}开发了一种方法为长细几何体如毛发等构建BVH；
因为这类几何体相对于其边界框体积来说非常细，
在大多数加速结构上它一般都有很差的性能。

BVH的内存要求可以非常大。在我们的实现中，每个节点为32字节。
场景中每个图元至多需要2个BVH树节点，每个图元的总开销可以高达64字节。
Cline等\parencite*{10.5555/2383894.2383909}建议为BVH节点使用更紧实的表示，牺牲一些效率。
首先，他们量化了每个节点中保存的边界框，用8或16字节来编码其相对于节点父亲边界框的位置。
然后，他们使用了{\itshape 隐式索引}\sidenote{译者注：原文implicit indexing。}，
其中节点$i$的孩子在节点数组中的位置为$2i$和$2i+1$（假设分支系数为$2\times$）。
他们证明节约了大量内存，而性能影响适中。
Bauszat等\parencite*{10.2312:PE:VMV:VMV10:227-234}开发了另一种在空间上高效的BVH表示。
也见Segovia和Ernst \parencite*{10.5555/1839214.1839242}开发的BVH节点与三角网格的紧实表示。

Yoon和Manocha \parencite*{10.1111/j.1467-8659.2006.00970.x}为
缓存高效的BVH和kd树布局提出了算法并展示了来自它们的性能提升。
也见\citet{10.5555/1121584}的书籍了解该话题的广泛讨论。

Lauterbach等\parencite*{10.1111/j.1467-8659.2009.01377.x}引入了线性BVH。
Pantaleoni和Luebke \parencite*{10.5555/1921479.1921493}在树的上层用SAH开发了HLBVH推广型。
他们还注意到莫顿编码值的高位可用于高效寻找图元群集——两种思想都用于我们HLBVH的开发。
Garanzha等\parencite*{10.1145/2018323.2018333}对HLBVH引入更多改进，
它们大多数都针对GPU实现。

不像HLBVH路线，这里\refvar{BVHAccel}{}中的BVH构建实现没有并行化。
详见\citet{5669303}了解始终利用SAH进行高性能并行BVH构建的方法。

\subsection{kd树}\label{sub:kd树}
\citet{6429331}为光线相交计算引入使用了八叉树。
\citet{kaplan1985use}\sidenote{译者注：未能找到该文献信息。}首先提出了为光线追踪使用kd树。
\citeauthor{kaplan1985use}的树构建算法总是从中间划分节点；
MacDonald和Booth \parencite*{MacDonald1990}引入了SAH方法，
用相对表面积估计光线-节点遍历概率。
\citet{Naylor1993:27}也写过关于构建优良kd树的一般问题。
Havran和Bittner \parencite*{HavranImproving2002}回顾了许多这些问题并介绍了有用的改进。
Hurley等\parencite*{hurley2002fast}提出为完全为空的树节点
添加补贴\sidenote{译者注：原文bonus。}因子到SAH中，就像我们的实现中做的那样。
见\citet{Havran2000:PhD}的博士论文了解对于高性能kd树构建和遍历算法的出色综述。


\citet{10.1007/978-3-642-71071-1_4}首次为kd树开发了高效的光线遍历算法。
\citet{ArvoRay1988}也研究了该问题并在《{\itshape\citefield{ArvoRay1988}{journaltitle}}》中一篇笔记里中作了讨论。
Sung和Shirley \parencite*{SUNG1992271}为BSP树加速器描述了一种光线遍历算法的实现；
我们的\refvar{KdTreeAccel}{}遍历代码一定程度上是基于它们的。

pbrt中kd树构建算法的渐进复杂度是$O(n\log^2n)$。
Wald和Havran \parencite*{4061547}证明了用一些额外实现的复杂度可以在$O(n\log n)$时间内构建kd-树；
它们为典型场景报告了$2$到$3\times$的构建时间加速。

光线追踪最好的kd树是用“完美划分”\sidenote{译者注：原文perfect splits。}构建的，
每一步中剪裁正插入到树中的图元以适应当前节点的边界。
这避免了一个问题，例如一个物体的边界框可能与节点的边界框相交因而被存储于其中，
然而该物体自己并没有与该节点的边界框相交。
该方法由Havran和Bittner \parencite*{HavranImproving2002}提出并
由Hurley等\parencite*{hurley2002fast}以及Wald和Havran \parencite*{4061547}进一步讨论。
也见Soupikov等\parencite*{4634623}。
即便用完美划分，大型图元仍可能存于许多个kd树叶子中；
Choi等\parencite*{10.1111/cgf.12241}建议在内部节点中存储一些图元以解决该问题。

kd树构建往往比BVH构建慢得多（尤其是如果使用了“完美划分”），
所以并行构建算法特别有意义。该领域的最新工作包括
Shevtsov等\parencite*{10.1111/j.1467-8659.2007.01062.x}和
Choi等\parencite*{10.5555/1921479.1921492}，
他们提出了对多处理器有良好扩展性的高效并行kd树构建算法。

\subsection{表面积启发法}\label{sub:表面积启发法2}
自MacDonald和Booth \parencite*{MacDonald1990}把SAH引入到
光线追踪以来许多研究者已经钻研了对SAH的改进。
Fabianowski等\parencite*{10.2312:egs.20091046}派生出的一个版本是把
光线在空间中均匀分布的假设替换为光线的起点均匀分布于场景的边界框中。
Hunt和Mark \parencite*{4634614}引入了新的SAH，
它导致事实上光线一般并不均匀分布但是它们许多都从单个点
或一组相邻点（分别为相机和光源）发出。\citet{4634625}展示了当使用
“邮箱”\sidenote{译者注：原文mailboxing。}优化时应该怎样修改SAH，
而Vinkler等\parencite*{VINKLER2012283}用关于图元可见性的假设来调整它们的SAH开销。
Ize和Hansen \parencite*{10.1111/j.1467-8659.2011.01861.x}派生出
“光线终止表面积启发法”\sidenote{译者注：原文ray termination surface area heuristic。}（RTSAH），
它们用其来为阴影射线调整BVH遍历顺序以更快找到与遮挡物的相交处。
也见Moulin等\parencite*{10.2312:sre.20151164}调整SAH以在kd树
遍历时对正被遮挡的阴影射线负责。

计算SAH会开销很大，尤其是当考虑许多不同的划分或图元分割时。
该问题的一个办法是只在候选点子集处计算它——例如，
沿着pbrt中\refvar{BVHAccel}{}里用的桶方法的直线来。
Hurley等\parencite*{hurley2002fast}为构建kd树推荐该方法，
而Popov等\parencite*{4061550}详细讨论了它。
Shevtsov等\parencite*{10.1111/j.1467-8659.2007.01062.x}引入了
将三角形全范围而不仅仅是其形心归入统计\sidenote{译者注：原文binning。}的改进。

Hunt等\parencite*{4061549}注意到例如如果你只需要在一点计算SAH，
则你不需要对图元排序而只需对它们做线性扫描以计算图元数量和该点的边界框。
他们证明了用基于其在许多独立点上的值得到的分段二次式来逼近SAH并
用它选择良好划分会得到高效的树。
Popov等\parencite*{4061550}用了类似的近似。

尽管SAH能得到非常高效的kd树和BVH，但明确的是它并不完美：
许多研究者已经注意到遇到有更高SAH估计开销的kd树或BVH比
具有最低估计开销的树给出更好性能的情况并不罕见。
Aila等\parencite*{10.1145/2492045.2492056}调查了他们的一些结果并
提出两个额外启发法帮助解决之；一个考虑了事实上大多数光线始于曲面——
光线起点实际上并不在场景中随机分布，另一个考虑了当多条光线一起穿过层级时
的SIMD\sidenote{译者注：single instruction multiple data，单指令流多数据流。}分散度。
尽管这些新层次在解释为什么给定的树提供了这样的性能上很有效，
但至今也不知道怎样将其与树构建算法搭配。

\subsection{加速结构的其他话题}\label{sub:加速结构的其他话题}
Weghorst、Hooper和Greenberg \parencite*{10.1145/357332.357335}讨论了
为包围盒使用不同形状的权衡方法并建议把物体投影到屏幕上
再使用$z$-缓存区渲染来为相机光线加速寻找相交处。

