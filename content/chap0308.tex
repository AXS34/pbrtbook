\section{细分曲面}\label{sec:细分曲面}
\begin{remark}
    本节含有高级内容，第一次阅读时可以跳过。
\end{remark}

本章我们要定义的最后一个形状表示
实现了\keyindex{细分曲面}{subdivision surface}{surface曲面}，
该表示尤其适合描述复杂光滑形状。
特定网格的细分曲面定义为将网格面反复细分为更小面
然后用旧顶点位置的加权组合求新顶点位置。

对于适当选择的细分规则，当细分步数趋于无穷时，
该过程会收敛到给出一个光滑的\keyindex{极限曲面}{limit surface}{surface曲面}。
实践中，只需少量级别的细分通常就足以得到极限曲面的良好近似。
\reffig{3.24}展示了一个细分的简单例子，
其中四面体被细分了零次、一次、两次和六次。
\begin{figure}[htbp]
    \centering\includegraphics[width=\linewidth]{chap03/tetsubdiv.png}
    \caption{四面体的细分。从左到右使用了零步、一步、两步和六步细分
        （在零级时，顶点只是移动到极限曲面上）。
        随着细分得越来越多，网格逼近极限曲面，即原始网格描述的光滑曲面。
        随着执行更多级别的细分，注意高光如何变得更加准确、轮廓边缘如何变得更加平滑。}
    \label{fig:3.24}
\end{figure}

\reffig{3.25}展示了对Killeroo\sidenote{译者注：猜测此名字与一澳大利亚漫画中的袋鼠角色名有关。}模型应用细分的效果；
上面是原始控制网格，下面是控制网格表示的细分曲面。
\begin{figure}[htbp]
    \centering
    \subfloat[控制网格]{\includegraphics[width=\linewidth]{chap03/killeroo-control.png}\label{fig:3.25.1}}\\
    \subfloat[细分网格]{\includegraphics[width=\linewidth]{chap03/killeroo-subdivided.png}\label{fig:3.25.2}}
    \caption{对Killeroo模型应用细分。(1)控制网格描述了(2)结果细分曲面。
        细分非常适合建模这样的形状，因为它能通过细化控制网格轻松添加局部细节，
        对最终曲面没有拓扑结构限制。（模型由headus/Rezard提供。）}
    \label{fig:3.25}
\end{figure}


因为在曲面的多边形和基于样条的表示方面有一些重要优势，
细分曲面近年来得到广泛运用，尽管它在20世纪70年代就被发明了。
细分的优势包括：
\begin{itemize}
    \item 细分曲面是平滑的，而多边形网格与之相反，无论建模得多细致，靠近观察会有小面。
    \item 建模系统中现有的多数基本结构可以重定向到细分。
          建模多边形网格的经典技术工具箱可以应用到建模细分控制网格上。
    \item 细分曲面非常适合描述有复杂拓扑结构的物体，
          因为它们以任意（\keyindex{流形}{manifold}{}）拓扑结构的控制网格为起点。
          参数化曲面模型一般不能很好地处理复杂拓扑结构。
    \item 细分方法常常是基于样条的曲面表示的推广，
          所以样条曲面常常可以由通用细分曲面渲染器运行。
    \item 通过简单地对控制网格的适当部分添加面，它能轻松对细分曲面局部区域添加细节。
          用样条表示则要困难得多。
\end{itemize}
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Subdivrefinement.tex}
    \caption{Loop细分的基本细化过程。（左）细分之前的控制网格。
        （右）一步细分后的新网格。通过划分每条边并连接新顶点和新边，
        网格的每个三角形面都被细分为四个新面。}
    \label{fig:3.26}
\end{figure}

这里，我们将介绍\keyindex{Loop细分曲面}{Loop subdivision surface}{surface曲面}
\footnote{以所用的细分规则发明者Charles Loop的名字命名。}的一种实现。
Loop细分规则基于控制网格中的三角形面；
开始时具有超过三个顶点的面被三角剖分。
在每步细分中，所有面分为四个子面（\reffig{3.26}）。
沿原始网格的所有边添加新顶点，
使用相邻顶点的加权平均计算位置。
而且，每个原始顶点的位置也用其位置和新邻居位置的加权平均更新。
这里的实现使用的权值基于Hoppe等\parencite*{10.1145/192161.192233}开发的
对Loop方法的改进。
我们这里不涵盖关于怎样推导出这些权值的讨论。
虽然需要精妙的数学推导证明它们确实满足了这一点，
但必须谨慎选择它们以保证极限曲面确实有特定期望的光滑性质。

细分曲面不是在pbrt中实现为\refvar{Shape}{}，
而是由函数\refvar{LoopSubdivide}{()}推广，
它将细分规则应用到一系列顶点和顶点索引表示的网格上
并返回表示最终细分网格的\refvar{Triangle}{}向量。
\begin{lstlisting}
`\initcode{LoopSubdiv Function Definitions}{=}\initnext{LoopSubdivFunctionDefinitions}`
std::vector<std::shared_ptr<`\refvar{Shape}{}`>> `\initvar{LoopSubdivide}{}`(
        const `\refvar{Transform}{}` *ObjectToWorld, const `\refvar{Transform}{}` *WorldToObject,
        bool reverseOrientation, int nLevels, int nIndices,
        const int *vertexIndices, int nVertices, const `\refvar{Point3f}{}` *p) {
    std::vector<`\refvar{SDVertex}{}` *> `\initvar{vertices}{}`;
    std::vector<`\refvar{SDFace}{}` *> `\initvar{faces}{}`;
    `\refcode{Allocate LoopSubdiv vertices and faces}{}`
    `\refcode{Set face to vertex pointers}{}`
    `\refcode{Set neighbor pointers in faces}{}`
    `\refcode{Finish vertex initialization}{}`
    `\refcode{Refine subdivision mesh into triangles}{}`
}
\end{lstlisting}

\subsection{网格表示}\label{sub:网格表示}
\refvar{LoopSubdivide}{()}的参数用和\refvar{TriangleMesh}{}构造函数中
一样的格式指定了三角网格（\refsec{三角形网格}）：
每个面由三个整数顶点索引描述，
给出面的三个顶点在顶点数组{\ttfamily p}中的偏移量。
我们需要处理该数据以决定哪些面彼此相邻，
哪些面和哪些顶点相邻等等，以实现细分算法。

我们将很快定义结构体\refvar{SDVertex}{}和\refvar{SDFace}{}，
它们存有细分网格中顶点和面的数据。
\refvar{LoopSubdivide}{()}从为网格中的每个顶点分配
一个\refvar{SDVertex}{}实例以及为每个面分配\refvar{SDFace}{}开始。
现在，它们几乎都没有初始化。
\begin{lstlisting}
`\initcode{Allocate LoopSubdiv vertices and faces}{=}`
std::unique_ptr<`\refvar{SDVertex}{}`[]> verts(new `\refvar{SDVertex}{}`[nVertices]);
for (int i = 0; i < nVertices; ++i) {
    verts[i] = `\refvar{SDVertex}{}`(p[i]);
    `\refvar{vertices}{}`.push_back(&verts[i]);
}
int nFaces = nIndices / 3;
std::unique_ptr<`\refvar{SDFace}{}`[]> fs(new `\refvar{SDFace}{}`[nFaces]);
for (int i = 0; i < nFaces; ++i)
    `\refvar{faces}{}`.push_back(&fs[i]);
\end{lstlisting}

Loop细分方案像多数其他细分方案那样，
假设控制网格是\keyindex{流形}{manifold}{}——
共享任意给定边的面不超过两个。
这样的网格可能是闭合的或开放的：\keyindex{闭合网格}{closed mesh}{mesh网格}没有
边界且所有面的每条边都有邻接面。\keyindex{开放网格}{open mesh}{mesh网格}有
一些面没有全部三个邻居。
这里的实现同时支持闭合和开放网格。

在三角网格内部，大多数顶点和六个面相邻且
有六个相邻顶点通过边直接与其相连。
在开放网格的边界上，大多数顶点与三个面和四个顶点相邻。
与一个顶点直接相邻的顶点数称为该顶点的\keyindex{价}{valence}{}。
价不是六的内部顶点或价不是四的边界顶点
称为\keyindex{非凡顶点}{extraordinary vertex}{vertex顶点}；
否则称为\keyindex{正则的}{regular}{}\footnote{这些术语常用于建模文献中，
    尽管“irregular”对“regular”或者“extraordinary”对“ordinary”更符合直觉。}。
Loop细分曲面在除非凡顶点外的任意处都是光滑的。

每个\refvar{SDVertex}{}存储其位置\refvar[SDVertex::p]{p}{}、
表示它是正则还是非凡顶点的布尔量以及
记录它是否位于网格边界上的布尔量。
它也存有指向任意与之相邻的面的指针；
该指针给出了寻找其所有相邻面的起点。
最后如果有的话，有一个指针为下一级的细分存储相应的\refvar{SDVertex}{}。
\begin{lstlisting}
`\initcode{LoopSubdiv Local Structures}{=}\initnext{LoopSubdivLocalStructures}`
struct `\initvar{SDVertex}{}` {
    `\refcode{SDVertex Constructor}{}`
    `\refcode{SDVertex Methods}{}`
    `\refvar{Point3f}{}` `\initvar[SDVertex::p]{p}{}`;
    `\refvar{SDFace}{}` *`\initvar{startFace}{}` = nullptr;
    `\refvar{SDVertex}{}` *`\initvar{child}{}` = nullptr;
    bool `\initvar{regular}{}` = false, `\initvar[SDVertex::boundary]{boundary}{}` = false;
};
\end{lstlisting}
\begin{lstlisting}
`\initcode{SDVertex Constructor}{=}`
`\refvar{SDVertex}{}`(const `\refvar{Point3f}{}` &p = `\refvar{Point3f}{}`(0, 0, 0)) : `\refvar[SDVertex::p]{p}{}`(p) { }
\end{lstlisting}

结构体\refvar{SDFace}{}存有最多关于网格的拓扑信息的地方。
因为所有面都是三角形，面总是存有指向其三个顶点的指针以及
指向其三条边相邻的面的指针。
如果面在开放网格边缘上则相应的相邻面指针为{\ttfamily nullptr}。

相邻面指针索引是，如果我们把从{\ttfamily\refvar[SDFace::v]{v}{}[i]}到{\ttfamily\refvar[SDFace::v]{v}{}[(i+1)\%3]}的边
标为第{\ttfamily i}边，则该边的相邻面存于{\ttfamily\refvar[SDFace::f]{f}{}[i]}（\reffig{3.27}）。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.35\linewidth]{chap03/Subdivvertfacepointers.eps}
    \caption{每个三角形面存有三个指向\protect\refvar{SDVertex}{}对象的
    指针{\ttfamily\protect\refvar[SDFace::v]{v}{}[i]}以及三个
    指向相邻面的指针{\ttfamily\protect\refvar[SDFace::f]{f}{}[i]}。
    相邻面索引使用的约定是第{\ttfamily i}边是
    从{\ttfamily\protect\refvar[SDFace::v]{v}{}[i]}到{\ttfamily\protect\refvar[SDFace::v]{v}{}[(i+1)\%3]}的边，
    且第{\ttfamily i}边的邻居在{\ttfamily\protect\refvar[SDFace::f]{f}{}[i]}中。}
    \label{fig:3.27}
\end{figure}
\begin{lstlisting}
`\refcode{LoopSubdiv Local Structures}{+=}\lastnext{LoopSubdivLocalStructures}`
struct `\initvar{SDFace}{}` {
    `\refcode{SDFace Constructor}{}`
    `\refcode{SDFace Methods}{}`
    `\refvar{SDVertex}{}` *`\initvar[SDFace::v]{v}{}`[3];
    `\refvar{SDFace}{}` *`\initvar[SDFace::f]{f}{}`[3];
    `\refvar{SDFace}{}` *`\initvar{children}{}`[4];
};
\end{lstlisting}
\subsection{细分}\label{sub:细分}