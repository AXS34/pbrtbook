\section{细分曲面}\label{sec:细分曲面}
\begin{remark}
    本节含有高级内容，第一次阅读时可以跳过。
\end{remark}

本章我们要定义的最后一个形状表示
实现了\keyindex{细分曲面}{subdivision surface}{surface曲面}，
该表示尤其适合描述复杂光滑形状。
特定网格的细分曲面定义为将网格面反复细分为更小面
然后用旧顶点位置的加权组合求新顶点位置。

对于适当选择的细分规则，当细分步数趋于无穷时，
该过程会收敛到给出一个光滑的\keyindex{极限曲面}{limit surface}{surface曲面}。
实践中，只需少量级别的细分通常就足以得到极限曲面的良好近似。
\reffig{3.24}展示了一个细分的简单例子，
其中四面体被细分了零次、一次、两次和六次。
\begin{figure}[htbp]
    \centering\includegraphics[width=\linewidth]{chap03/tetsubdiv.png}
    \caption{四面体的细分。从左到右使用了零步、一步、两步和六步细分
        （在零级时，顶点只是移动到极限曲面上）。
        随着细分得越来越多，网格逼近极限曲面，即原始网格描述的光滑曲面。
        随着执行更多级别的细分，注意高光如何变得更加准确、轮廓边缘如何变得更加平滑。}
    \label{fig:3.24}
\end{figure}

\reffig{3.25}展示了对Killeroo\sidenote{译者注：猜测此名字与一澳大利亚漫画中的袋鼠角色名有关。}模型应用细分的效果；
上面是原始控制网格，下面是控制网格表示的细分曲面。
\begin{figure}[htbp]
    \centering
    \subfloat[控制网格]{\includegraphics[width=\linewidth]{chap03/killeroo-control.png}\label{fig:3.25.1}}\\
    \subfloat[细分网格]{\includegraphics[width=\linewidth]{chap03/killeroo-subdivided.png}\label{fig:3.25.2}}
    \caption{对Killeroo模型应用细分。(1)控制网格描述了(2)结果细分曲面。
        细分非常适合建模这样的形状，因为它能通过细化控制网格轻松添加局部细节，
        对最终曲面没有拓扑结构限制。（模型由headus/Rezard提供。）}
    \label{fig:3.25}
\end{figure}


因为在曲面的多边形和基于样条的表示方面有一些重要优势，
细分曲面近年来得到广泛运用，尽管它在20世纪70年代就被发明了。
细分的优势包括：
\begin{itemize}
    \item 细分曲面是平滑的，而多边形网格与之相反，无论建模得多细致，靠近观察会有小面。
    \item 建模系统中现有的多数基本结构可以重定向到细分。
          建模多边形网格的经典技术工具箱可以应用到建模细分控制网格上。
    \item 细分曲面非常适合描述有复杂拓扑结构的物体，
          因为它们以任意（\keyindex{流形}{manifold}{}）拓扑结构的控制网格为起点。
          参数化曲面模型一般不能很好地处理复杂拓扑结构。
    \item 细分方法常常是基于样条的曲面表示的推广，
          所以样条曲面常常可以由通用细分曲面渲染器运行。
    \item 通过简单地对控制网格的适当部分添加面，它能轻松对细分曲面局部区域添加细节。
          用样条表示则要困难得多。
\end{itemize}
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Subdivrefinement.tex}
    \caption{Loop细分的基本细化过程。（左）细分之前的控制网格。
        （右）一步细分后的新网格。通过划分每条边并连接新顶点和新边，
        网格的每个三角形面都被细分为四个新面。}
    \label{fig:3.26}
\end{figure}

这里，我们将介绍\keyindex{Loop细分曲面}{Loop subdivision surface}{surface曲面}
\footnote{以所用的细分规则发明者Charles Loop的名字命名。}的一种实现。
Loop细分规则基于控制网格中的三角形面；
开始时具有超过三个顶点的面被三角剖分。
在每步细分中，所有面分为四个子面（\reffig{3.26}）。
沿原始网格的所有边添加新顶点，
使用相邻顶点的加权平均计算位置。
而且，每个原始顶点的位置也用其位置和新邻居位置的加权平均更新。
这里的实现使用的权值基于Hoppe等\parencite*{10.1145/192161.192233}开发的
对Loop方法的改进。
我们这里不涵盖关于怎样推导出这些权值的讨论。
虽然需要精妙的数学推导证明它们确实满足了这一点，
但必须谨慎选择它们以保证极限曲面确实有特定期望的光滑性质。

细分曲面不是在pbrt中实现为\refvar{Shape}{}，
而是由函数\refvar{LoopSubdivide}{()}推广，
它将细分规则应用到一系列顶点和顶点索引表示的网格上
并返回表示最终细分网格的\refvar{Triangle}{}向量。
\begin{lstlisting}
`\initcode{LoopSubdiv Function Definitions}{=}\initnext{LoopSubdivFunctionDefinitions}`
std::vector<std::shared_ptr<`\refvar{Shape}{}`>> `\initvar{LoopSubdivide}{}`(
        const `\refvar{Transform}{}` *ObjectToWorld, const `\refvar{Transform}{}` *WorldToObject,
        bool reverseOrientation, int nLevels, int nIndices,
        const int *vertexIndices, int nVertices, const `\refvar{Point3f}{}` *p) {
    std::vector<`\refvar{SDVertex}{}` *> vertices;
    std::vector<`\refvar{SDFace}{}` *> faces;
    `\refcode{Allocate LoopSubdiv vertices and faces}{}`
    `\refcode{Set face to vertex pointers}{}`
    `\refcode{Set neighbor pointers in faces}{}`
    `\refcode{Finish vertex initialization}{}`
    `\refcode{Refine subdivision mesh into triangles}{}`
}
\end{lstlisting}

\subsection{网格表示}\label{sub:网格表示}
\refvar{LoopSubdivide}{()}的参数用和\refvar{TriangleMesh}{}构造函数中
一样的格式指定了三角网格（\refsec{三角形网格}）：
每个面由三个整数顶点索引描述，
给出面的三个顶点在顶点数组{\ttfamily p}中的偏移量。
我们需要处理该数据以决定哪些面彼此相邻，
哪些面和哪些顶点相邻等等，以实现细分算法。

我们将很快定义结构体\refvar{SDVertex}{}和\refvar{SDFace}{}，
它们存有细分网格中顶点和面的数据。
\refvar{LoopSubdivide}{()}从为网格中的每个顶点分配
一个\refvar{SDVertex}{}实例以及为每个面分配\refvar{SDFace}{}开始。
现在，它们几乎都没有初始化。
\begin{lstlisting}
`\initcode{Allocate LoopSubdiv vertices and faces}{=}`
std::unique_ptr<`\refvar{SDVertex}{}`[]> verts(new `\refvar{SDVertex}{}`[nVertices]);
for (int i = 0; i < nVertices; ++i) {
    verts[i] = `\refvar{SDVertex}{}`(p[i]);
    vertices.push_back(&verts[i]);
}
int nFaces = nIndices / 3;
std::unique_ptr<`\refvar{SDFace}{}`[]> fs(new `\refvar{SDFace}{}`[nFaces]);
for (int i = 0; i < nFaces; ++i)
    faces.push_back(&fs[i]);
\end{lstlisting}

Loop细分方案像多数其他细分方案那样，
假设控制网格是\keyindex{流形}{manifold}{}——
共享任意给定边的面不超过两个。
这样的网格可能是闭合的或开放的：\keyindex{闭合网格}{closed mesh}{mesh网格}没有
边界且所有面的每条边都有邻接面。\keyindex{开放网格}{open mesh}{mesh网格}有
一些面没有全部三个邻居。
这里的实现同时支持闭合和开放网格。

在三角网格内部，大多数顶点和六个面相邻且
有六个相邻顶点通过边直接与其相连。
在开放网格的边界上，大多数顶点与三个面和四个顶点相邻。
与一个顶点直接相邻的顶点数称为该顶点的\keyindex{价}{valence}{}。
价不是六的内部顶点或价不是四的边界顶点
称为\keyindex{非凡顶点}{extraordinary vertex}{vertex顶点}；
否则称为\keyindex{正则的}{regular}{}\footnote{这些术语常用于建模文献中，
    尽管“irregular”对“regular”或者“extraordinary”对“ordinary”更符合直觉。}。
Loop细分曲面在除非凡顶点外的任意处都是光滑的。

每个\refvar{SDVertex}{}存储其位置\refvar[SDVertex::p]{p}{}、
表示它是正则还是非凡顶点的布尔量以及
记录它是否位于网格边界上的布尔量。
它也存有指向任意与之相邻的面的指针；
该指针给出了寻找其所有相邻面的起点。
最后如果有的话，有一个指针为下一级的细分存储相应的\refvar{SDVertex}{}。
\begin{lstlisting}
`\initcode{LoopSubdiv Local Structures}{=}\initnext{LoopSubdivLocalStructures}`
struct `\initvar{SDVertex}{}` {
    `\refcode{SDVertex Constructor}{}`
    `\refcode{SDVertex Methods}{}`
    `\refvar{Point3f}{}` `\initvar[SDVertex::p]{p}{}`;
    `\refvar{SDFace}{}` *`\initvar{startFace}{}` = nullptr;
    `\refvar{SDVertex}{}` *`\initvar{child}{}` = nullptr;
    bool `\initvar{regular}{}` = false, `\initvar[SDVertex::boundary]{boundary}{}` = false;
};
\end{lstlisting}
\begin{lstlisting}
`\initcode{SDVertex Constructor}{=}`
`\refvar{SDVertex}{}`(const `\refvar{Point3f}{}` &p = `\refvar{Point3f}{}`(0, 0, 0)) : `\refvar[SDVertex::p]{p}{}`(p) { }
\end{lstlisting}

结构体\refvar{SDFace}{}存有最多关于网格的拓扑信息的地方。
因为所有面都是三角形，面总是存有指向其三个顶点的指针以及
指向其三条边相邻的面的指针。
如果面在开放网格边缘上则相应的相邻面指针为{\ttfamily nullptr}。

相邻面指针索引是，如果我们把从{\ttfamily\refvar[SDFace::v]{v}{}[i]}到{\ttfamily\refvar[SDFace::v]{v}{}[(i+1)\%3]}的边
标为第{\ttfamily i}边，则该边的相邻面存于{\ttfamily\refvar[SDFace::f]{f}{}[i]}（\reffig{3.27}）。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.35\linewidth]{chap03/Subdivvertfacepointers.eps}
    \caption{每个三角形面存有三个指向\protect\refvar{SDVertex}{}对象的
    指针{\ttfamily\protect\refvar[SDFace::v]{v}{}[i]}以及三个
    指向相邻面的指针{\ttfamily\protect\refvar[SDFace::f]{f}{}[i]}。
    相邻面索引使用的约定是第{\ttfamily i}边是
    从{\ttfamily\protect\refvar[SDFace::v]{v}{}[i]}到{\ttfamily\protect\refvar[SDFace::v]{v}{}[(i+1)\%3]}的边，
    且第{\ttfamily i}边的邻居在{\ttfamily\protect\refvar[SDFace::f]{f}{}[i]}中。}
    \label{fig:3.27}
\end{figure}

\begin{lstlisting}
`\refcode{LoopSubdiv Local Structures}{+=}\lastnext{LoopSubdivLocalStructures}`
struct `\initvar{SDFace}{}` {
    `\refcode{SDFace Constructor}{}`
    `\refcode{SDFace Methods}{}`
    `\refvar{SDVertex}{}` *`\initvar[SDFace::v]{v}{}`[3];
    `\refvar{SDFace}{}` *`\initvar[SDFace::f]{f}{}`[3];
    `\refvar{SDFace}{}` *`\initvar{children}{}`[4];
};
\end{lstlisting}

\refvar{SDFace}{}构造函数很简单——它简单地把这些不同的指针设置为{\ttfamily nullptr}——
所以这里不再展示。

为简化\refvar{SDFace}{}的数据结构导航，
我们提供宏使得决定特定索引前后的顶点和面索引更容易。
这些宏添加适合的偏移量并计算模三结果以负责循环。
\begin{lstlisting}
`\initcode{LoopSubdiv Macros}{=}`
#define `\initvar{NEXT}{}`(i) (((i) + 1) % 3)
#define `\initvar{PREV}{}`(i) (((i) + 2) % 3)
\end{lstlisting}

除了需要流形网格外，细分代码希望用户指定的控制网格
是\keyindex{相容次序}{consistently ordered}{}的——
网格中每条\keyindex{有向边}{directed edge}{edge边}只出现一次。
两个面的公共边须由每个面指定为不同方向。
考虑两个顶点$\bm v_0$和$\bm v_1$与连接它们的边。
我们希望拥有该边的三角形面指定其三个顶点时$\bm v_0$在$\bm v_1$之前，
另一个面指定顶点时$\bm v_1$在$\bm v_0$之前（\reffig{3.28}）。
\keyindex{莫比乌斯带}{Möbius strip}{}是无法相容次序的曲面例子，
但渲染中几乎不会遇到这样的曲面，所以实践中该限制没问题。
然而不能创建相容次序网格的程序给出的没构建好的网格数据可能会造成问题。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Subdivfaceorientation.tex}
    \caption{输入网格中的所有面必须指定为让每条公共边在每个方向最多出现一次。
        这里，从$\bm v_0$到$\bm v_1$的边被一个面从$\bm v_0$到$\bm v_1$穿过
        而被另一个面从$\bm v_1$到$\bm v_0$穿过。
        另一个看待方式是考虑面朝向：从网格外边观察时，
        所有面的顶点应该统一地以顺时针或逆时针顺序给出。}
    \label{fig:3.28}
\end{figure}

有了关于输入数据的该假设，\refvar{LoopSubdivide}{()}现在
可以初始化网格的拓扑数据结构了。
它首先遍历所有面并设置它们的指针\refvar[SDFace::v]{v}{}指向它们的三个顶点。
它还设置每个顶点的指针\refvar[startFace]{SDVertex::startFace}{}指向
该顶点相邻面中的一个。具体使用哪一个相邻面并不重要，
所以每次遇到该顶点关联的另一个面时，该实现就重设它，
这条保证所有顶点在遍历完成前都有非空的面指针。
\begin{lstlisting}
`\initcode{Set face to vertex pointers}{=}`
const int *vp = vertexIndices;
for (int i = 0; i < nFaces; ++i, vp += 3) {
    SDFace *f = faces[i];
    for (int j = 0; j < 3; ++j) {
        SDVertex *v = vertices[vp[j]];
        f->`\refvar[SDFace::v]{v}{}`[j] = v;
        v->`\refvar{startFace}{}` = f;
    }
}
\end{lstlisting}

现在有必要将每个面的\refvar[SDFace::f]{f}{}指针设置为指向其相邻面。
这有些棘手，因为传入
\refvar{LoopSubdivide}{()}的数据并不直接指定面的相邻信息。
这里的实现遍历面并为其三条边的每一条都创建\refvar{SDEdge}{}对象。
当遇到另一个面共享同一边时，它就更新两个面的相邻指针。
\begin{lstlisting}
`\refcode{LoopSubdiv Local Structures}{+=}\lastcode{LoopSubdivLocalStructures}`
struct `\initvar{SDEdge}{}` {
    `\refcode{SDEdge Constructor}{}`
    `\refcode{SDEdge Comparison Function}{}`
    `\refvar{SDVertex}{}` *`\initvar[SDEdge::v]{v}{}`[2];
    `\refvar{SDFace}{}` *`\initvar[SDEdge::f]{f}{}`[2];
    int `\initvar{f0edgeNum}{}`;
};
\end{lstlisting}

\refvar{SDEdge}{}构造函数接收指向边的两端顶点的指针。
它对指针排序使得{\ttfamily\refvar[SDEdge::v]{v}{}[0]}是
排在内存中最前面的那个。这段代码可能看起来很奇怪，
但它简单依赖于这样的事实即C++中的指针是可以像整数那样高效操作的数字
\footnote{尽管是分段架构。}而一边的顶点顺序是任意的。
基于其指针地址排列这两个顶点保证了边$(\bm v_a,\bm v_b)$可以
被正确认作和边$(\bm v_b,\bm v_a)$相同，而不管提供的顶点顺序是什么。
\begin{lstlisting}
`\initcode{SDEdge Constructor}{=}`
`\refvar{SDEdge}{}`(`\refvar{SDVertex}{}` *v0 = nullptr, `\refvar{SDVertex}{}` *v1 = nullptr) {
    `\refvar[SDEdge::v]{v}{}`[0] = std::min(v0, v1);
    `\refvar[SDEdge::v]{v}{}`[1] = std::max(v0, v1);
    `\refvar[SDEdge::f]{f}{}`[0] = `\refvar[SDEdge::f]{f}{}`[1] = nullptr;
    `\refvar{f0edgeNum}{}` = -1;
}
\end{lstlisting}

该类还定义了\refvar{SDEdge}{}对象的排序操作
这样它们就能存于其他依赖良好顺序定义的数据结构。
\begin{lstlisting}
`\initcode{SDEdge Comparison Function}{=}`
bool operator<(const `\refvar{SDEdge}{}` &e2) const {
    if (`\refvar[SDEdge::v]{v}{}`[0] == e2.`\refvar[SDEdge::v]{v}{}`[0]) return `\refvar[SDEdge::v]{v}{}`[1] < e2.`\refvar[SDEdge::v]{v}{}`[1];
    return `\refvar[SDEdge::v]{v}{}`[0] < e2.`\refvar[SDEdge::v]{v}{}`[0];
}
\end{lstlisting}

现在函数\refvar{LoopSubdivide}{()}可以开始工作了，
遍历所有面的边并随之更新相邻指针。
它用{\ttfamily set}存储目前只有一个相邻面的边。
{\ttfamily set}让在$O(\log{n})$时间内搜索特定边成为可能。
\begin{lstlisting}
`\initcode{Set neighbor pointers in faces}{=}`
std::set<`\refvar{SDEdge}{}`> edges;
for (int i = 0; i < nFaces; ++i) {
    `\refvar{SDFace}{}` *f = faces[i];
    for (int edgeNum = 0; edgeNum < 3; ++edgeNum) {
        `\refcode{Update neighbor pointer for edgeNum}{}`
    }
}
\end{lstlisting}

对于每个面中的每条边，循环体创建一个边对象并检查之前是否已经见过同样的边。
如果是，它就初始化共享该边的两个面的相邻指针。
如果否，它就将该边添加到边的集合中。
该边两端两个顶点的索引{\ttfamily v0}和{\ttfamily v1}，
分别等于边的索引和边的边的索引加一。
\begin{lstlisting}
`\initcode{Update neighbor pointer for edgeNum}{=}`
int v0 = edgeNum, v1 = `\refvar{NEXT}{}`(edgeNum);
`\refvar{SDEdge}{}` e(f->`\refvar[SDFace::v]{v}{}`[v0], f->`\refvar[SDFace::v]{v}{}`[v1]);
if (edges.find(e) == edges.end()) {
    `\refcode{Handle new edge}{}`
} else {
    `\refcode{Handle previously seen edge}{}`
}
\end{lstlisting}

给定之前没遇到的边，当前的面的指针存储于边对象的成员{\ttfamily\refvar[SDEdge::f]{f}{}[0]}中。
因为假设输入网格是流形，所以最多还有另一个面共享这条边。
当发现该面时，可以用它初始化相邻面的域。
在当前的面中存储该边的号码能让相邻面初始化其相应相邻边的指针。
\begin{lstlisting}
`\initcode{Handle new edge}{=}`
e.`\refvar[SDEdge::f]{f}{}`[0] = f;
e.`\refvar{f0edgeNum}{}` = edgeNum;
edges.insert(e);
\end{lstlisting}

当找到该边上的第二个面时，两个面都设置相邻指针。
然后从边的集合中移除该边，因为没有边可以被两个以上的面共享。
\begin{lstlisting}
`\initcode{Handle previously seen edge}{=}`
e = *edges.find(e);
e.`\refvar[SDEdge::f]{f}{}`[0]->`\refvar[SDFace::f]{f}{}`[e.`\refvar{f0edgeNum}{}`] = f;
f->`\refvar[SDFace::f]{f}{}`[edgeNum] = e.`\refvar[SDEdge::f]{f}{}`[0];
edges.erase(e);
\end{lstlisting}

现在所有面都有合适的相邻指针，
可以设置每个顶点中的标志\refvar[SDVertex::boundary]{boundary}{}和
\refvar{regular}{}了。为了确定顶点是否是边界顶点，我们将定义围绕顶点的面顺序（\reffig{3.29}）。
对于面{\ttfamily f}上的顶点{\ttfamily\refvar[SDFace::v]{v}{}[i]}，
我们定义顶点的\emph{下一面}是邻接从{\ttfamily\refvar[SDFace::v]{v}{}[i]}到{\ttfamily\refvar[SDFace::v]{v}{}[\refvar{NEXT}{}(i)]}的边的面，
\emph{上一面}是邻接从{\ttfamily\refvar[SDFace::v]{v}{}[\refvar{PREV}{}(i)]}到{\ttfamily\refvar[SDFace::v]{v}{}[i]}的边的面。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.4\linewidth]{chap03/Subdivprevnextface.eps}
    \caption{给定顶点{\ttfamily\refvar[SDFace::v]{v}{}[i]}和附带的面{\ttfamily f}，
    我们定义\emph{下一面}为与{\ttfamily f}通过
    从{\ttfamily\protect\refvar[SDFace::v]{v}{}[i]}到{\ttfamily\protect\refvar[SDFace::v]{v}{}[\protect\refvar{NEXT}{}(i)]}的边邻接的面。
    上一面的定义类似。}
    \label{fig:3.29}
\end{figure}

通过依次转到围绕\refvar[SDFace::v]{v}{}的下一面，
我们可以遍历与之相邻的面。
如果我们最终回到出发的面，则我们位于内部顶点上；
如果我们遇到一条边的相邻指针是{\ttfamily nullptr}，
则我们位于边界顶点上（\reffig{3.30}）。
一旦初始化例程确定这是否是边界顶点，
它就计算顶点的价，如果是价为6的内部顶点或价为4的边界顶点，
就置位标志\refvar{regular}{}；否则这是个非凡顶点。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.5\linewidth]{chap03/Subdivdetermineboundary.eps}
    \caption{我们可以通过从相邻面\protect\refvar{startFace}{}开始
        并跟随围绕该顶点的下一面指针来确定一个顶点是否是边界顶点。
        如果我们遇到一个没有下一相邻面的面，则该顶点在边界上。
        如果我们回到\protect\refvar{startFace}{}，则它是内部顶点。}
    \label{fig:3.30}
\end{figure}

\begin{lstlisting}
`\initcode{Finish vertex initialization}{=}`
for (int i = 0; i < nVertices; ++i) {
    `\refvar{SDVertex}{}` *v = vertices[i];
    `\refvar{SDFace}{}` *f = v->`\refvar{startFace}{}`;
    do {
        f = f->`\refvar{nextFace}{}`(v);
    } while (f && f != v->`\refvar{startFace}{}`);
    v->`\refvar[SDVertex::boundary]{boundary}{}` = (f == nullptr);
    if (!v->`\refvar[SDVertex::boundary]{boundary}{}` && v->`\refvar{valence}{}`() == 6)
        v->`\refvar{regular}{}` = true;
    else if (v->`\refvar[SDVertex::boundary]{boundary}{}` && v->`\refvar{valence}{}`() == 4)
        v->`\refvar{regular}{}` = true;
    else
        v->`\refvar{regular}{}` = false;
}
\end{lstlisting}

因为经常需要顶点的价，所以我们提供方法\refvar[valence]{SDVertex::valence}{()}。
\begin{lstlisting}
`\initcode{LoopSubdiv Inline Functions}{=}\initnext{LoopSubdivInlineFunctions}`
inline int `\refvar{SDVertex}{}`::`\initvar{valence}{}`() {
    `\refvar{SDFace}{}` *f = `\refvar{startFace}{}`;
    if (!`\refvar[SDVertex::boundary]{boundary}{}`) {
        `\refcode{Compute valence of interior vertex}{}`
    } else {
        `\refcode{Compute valence of boundary vertex}{}`
    }
}
\end{lstlisting}

为了计算非边界顶点的价，该方法跟随每个面围绕该顶点的相邻指针
开始计算相邻面的数量，直到它回到出发的面。
价等于访问的面的数量。
\begin{lstlisting}
`\initcode{Compute valence of interior vertex}{=}`
int nf = 1;
while ((f = f->`\refvar{nextFace}{}`(this)) != `\refvar{startFace}{}`)
    ++nf;
return nf;
\end{lstlisting}

对于边界顶点我们可以用相同的方法，但这种情况下价比相邻面的数量多一。
这里遍历相邻面稍微更复杂些：它跟随围绕该顶点的下一面指针直到遇到边界，计算见过的面的数量。
然后它再次从\refvar{startFace}{}开始并跟随上一面指针直到在另一方向遇到边界。
\begin{lstlisting}
`\initcode{Compute valence of boundary vertex}{=}`
int nf = 1;
while ((f = f->`\refvar{nextFace}{}`(this)) != nullptr)
    ++nf;
f = `\refvar{startFace}{}`;
while ((f = f->`\refvar{prevFace}{}`(this)) != nullptr)
    ++nf;
return nf + 1;
\end{lstlisting}

\refvar[vnum]{SDFace::vnum}{()}是查找给定顶点指针的索引的实用函数。
传入一个不属于当前的面的顶点指针是致命错误——
这种情况表明细分代码中有bug。
\begin{lstlisting}
`\initcode{SDFace Methods}{=}\initnext{SDFaceMethods}`
int `\initvar{vnum}{}`(`\refvar{SDVertex}{}` *vert) const {
    for (int i = 0; i < 3; ++i)
        if (`\refvar[SDFace::v]{v}{}`[i] == vert) return i;
    `\refvar{Severe}{}`("Basic logic error in SDFace::vnum()");
    return -1;
}
\end{lstlisting}

因为面{\ttfamily f}上顶点{\ttfamily\refvar[SDFace::v]{v}{}[i]}的
下一面在第i边上（回想\reffig{3.27}中相邻边指针的映射），
给定实用函数\refvar{vnum}{()}提供的顶点索引{\ttfamily i}，
我们可轻松找出合适的相邻面指针。
上一面邻接从{\ttfamily\refvar{PREV}{}(i)}到{\ttfamily i}的边，
所以对于上一面该方法返回{\ttfamily \refvar[SDFace::f]{f}{}[\refvar{PREV}{}(i)]}。
\begin{lstlisting}
`\refcode{SDFace Methods}{+=}\lastnext{SDFaceMethods}`
`\refvar{SDFace}{}` *`\initvar{nextFace}{}`(`\refvar{SDVertex}{}` *vert) {
    return `\refvar[SDFace::f]{f}{}`[`\refvar{vnum}{}`(vert)];
}
\end{lstlisting}
\begin{lstlisting}
`\refcode{SDFace Methods}{+=}\lastnext{SDFaceMethods}`
`\refvar{SDFace}{}` *`\initvar{prevFace}{}`(`\refvar{SDVertex}{}` *vert) {
    return `\refvar[SDFace::f]{f}{}`[`\refvar{PREV}{}`(`\refvar{vnum}{}`(vert))];
}
\end{lstlisting}

能够从任意顶点开始获取围绕一个面的上一个和下一个顶点也很有用。
方法\refvar[nextVert]{SDFace::nextVert}{()}和\refvar[prevVert]{SDFace::prevVert}{()}就是干这个的（\reffig{3.31}）。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.35\linewidth]{chap03/Subdivprevnextvert.eps}
    \caption{给定顶点{\ttfamily v}和面{\ttfamily f}，
    方法{\ttfamily f->\protect\refvar{prevVert}{}(v)}返回
    从{\ttfamily v}起绕该面的上一个顶点，
    而{\ttfamily f->\protect\refvar{nextVert}{}(v)}返回下一个顶点，
    其中“下一个”和“上一个”由定义该面时的顶点原始顺序定义。}
    \label{fig:3.31}
\end{figure}

\begin{lstlisting}
`\refcode{SDFace Methods}{+=}\lastnext{SDFaceMethods}`
`\refvar{SDVertex}{}` *`\initvar{nextVert}{}`(`\refvar{SDVertex}{}` *vert) {
    return `\refvar[SDFace::v]{v}{}`[`\refvar{NEXT}{}`(`\refvar{vnum}{}`(vert))];
}
\end{lstlisting}
\begin{lstlisting}
`\refcode{SDFace Methods}{+=}\lastnext{SDFaceMethods}`
`\refvar{SDVertex}{}` *`\initvar{prevVert}{}`(`\refvar{SDVertex}{}` *vert) {
    return `\refvar[SDFace::v]{v}{}`[`\refvar{PREV}{}`(`\refvar{vnum}{}`(vert))];
}
\end{lstlisting}

\subsection{细分}\label{sub:细分}
现在我们可以展示怎样用修改后的Loop规则进行细分了。